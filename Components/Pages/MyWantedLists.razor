@page "/mywantedlists"

@using brickapp.Data.Entities
@using brickapp.Data.Services
@using brickapp.Data.DTOs
@using brickapp.Helpers
@using brickapp.Components.Shared.PartsListUpload
@using static brickapp.Data.Services.WantedListService

@inject brickapp.Data.Services.WantedListService WantedListService
@inject brickapp.Data.Services.MappedBrickService MappedBrickService
@inject brickapp.Data.Services.ImageService ImageService
@inject NavigationManager Nav
@inject brickapp.Data.Services.LoadingService LoadingService
@inject brickapp.Data.Services.NotificationService NotificationService

<PageTitle>My Wanted Lists</PageTitle>

<MudText Typo="Typo.h4" GutterBottom="true">My Wanted Lists</MudText>

@if (!string.IsNullOrWhiteSpace(_error))
{
    <MudAlert Severity="Severity.Error" Variant="Variant.Filled" Class="mb-4">
        @_error
        @if (!string.IsNullOrWhiteSpace(_errorDetails))
        {
            <MudDivider Class="my-2" />
            <MudText Typo="Typo.caption" Style="white-space:pre-wrap;">@_errorDetails</MudText>
        }
    </MudAlert>
}

<style>
    .brick {
        position: relative;
        display: inline-block;
        width: 56px;
        height: 56px;
        min-width: 56px;
        min-height: 56px;
        box-sizing: border-box;
    }

    .brick-img {
        width: 100%;
        height: 100%;
        object-fit: contain;
        border-radius: 4px;
        border: 2px solid #ccc;
        background: #fff;
        display: block;
    }

    .brick::after {
        content: "";
        position: absolute;
        right: .5px;
        bottom: 0px;
        width: 0;
        height: 0;
        border-bottom: 28px solid var(--brick-color, transparent);
        border-left: 28px solid transparent;
        border-radius: 0 0 4px 0;
        z-index: 2;
        pointer-events: none;
    }
</style>

<MudPaper Class="pa-4 mt-6">
    <MudText Typo="Typo.h5" GutterBottom="true">Create new wanted list</MudText>

    <EditForm Model="newListModel" OnValidSubmit="HandleCreateWantedList">
        <MudTextField @bind-Value="newListModel.Name" Label="List name" Required="true" Class="mb-2" />

        <MudTabs Elevation="2" Rounded="true" ApplyEffectsToContainer="true" PanelClass="pa-6" Class="my-8">
            <MudTabPanel Text="Upload a item list">
                <PartsListUploader Title="Upload wanted list file"
                                   AddButtonText="Add uploaded items to your list"
                                   ClearButtonText="Clear upload"
                                   OnParsed="OnUploadParsed"
                                   OnAdd="AddUploadItemsToNewList_FromComponent"
                                   OnCleared="OnUploadCleared" />
            </MudTabPanel>

            <MudTabPanel Text="Add items manually">
                <MudText Typo="Typo.h6" GutterBottom="true">Add items manually</MudText>

                <MudTextField T="string"
                              Value="@brickSearchText"
                              ValueChanged="OnBrickSearchChanged"
                              Immediate="true"
                              Label="Search brick"
                              Class="mb-2" />

                @if (_searching)
                {
                    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2" Class="mb-2">
                        <MudProgressCircular Indeterminate="true" Size="Size.Small" />
                        <MudText Typo="Typo.body2">Searching…</MudText>
                    </MudStack>
                }

                @if (brickSearchResults.Any())
                {
                    <MudList T="MappedBrick">
                        @foreach (var brick in brickSearchResults)
                        {
                            <MudListItem T="MappedBrick"
                                         Style="cursor:pointer;display:flex;align-items:center;"
                                         OnClick="@(() => SelectBrick(brick))">
                                <img src="@ImageService.GetMappedBrickImagePath(brick)" alt=""
                                     style="width:32px;height:32px;object-fit:contain;margin-right:8px;vertical-align:middle;border-radius:4px;border:1px solid #ccc;" />
                                @brick.Name (@brick.LegoPartNum)
                            </MudListItem>
                        }
                    </MudList>
                }

                @if (selectedBrick != null)
                {
                    <div style="margin-bottom:8px;display:flex;align-items:center;">
                        @{
                            var selectedColorName = selectedColorId.HasValue
                                ? brickColors.FirstOrDefault(c => c.Id == selectedColorId.Value)?.Name
                                : null;

                            var overlay = BrickColorHelper.GetHexForColor(selectedColorName);
                            var overlayCss = overlay ?? "transparent";

                            var url = ImageService.GetMappedBrickImagePath(selectedBrick);
                            var hasImage = !string.IsNullOrWhiteSpace(url) && url != "/placeholder-image.png";
                        }

                        <div class="brick"
                             style="--brick-color:@overlayCss; width:48px; height:48px; min-width:48px; min-height:48px; margin-right:8px;">
                            <img src="@(hasImage ? url : "/placeholder-image.png")"
                                 alt=""
                                 class="brick-img"
                                 style="border-width:1px;@(hasImage ? "" : "opacity:0.5;")"
                                 onerror="if(this.src!=='/placeholder-image.png'){this.src='/placeholder-image.png';this.style.opacity='0.5';}" />
                        </div>

                        <span style="font-weight:500;">
                            @selectedBrick.Name
                            @if (!string.IsNullOrWhiteSpace(selectedBrick.LegoPartNum))
                            {
                                <span style="color:#888;">(@selectedBrick.LegoPartNum)</span>
                            }
                        </span>
                    </div>

                    <MudSelect T="int?" @bind-Value="selectedColorId"
                               Label="Color"
                               Placeholder="Please select a color"
                               Variant="Variant.Text"
                               Dense="true"
                               Class="mb-2"
                               Style="max-width:300px;">
                        @foreach (var color in brickColors)
                        {
                            <MudSelectItem T="int?" Value="@color.Id">@color.Name</MudSelectItem>
                        }
                    </MudSelect>

                    <MudNumericField T="int" @bind-Value="brickQuantity"
                                     Label="Quantity" Min="1" Max="999"
                                     Variant="Variant.Text" Dense="true"
                                     Class="mb-2" Style="max-width:300px;" />

                    <MudButton Variant="Variant.Filled"
                               Color="Color.Primary"
                               OnClick="AddBrickToList"
                               Disabled="@(selectedColorId is null)"
                               Class="mb-2">
                        Add item
                    </MudButton>
                    <br />
                }
            </MudTabPanel>
        </MudTabs>

        <MudButton Variant="Variant.Filled"
                   StartIcon="@Icons.Material.Filled.Save"
                   Color="Color.Success"
                   Size="Size.Large"
                   ButtonType="ButtonType.Submit"
                   Disabled="@(_saving || !newListModel.Items.Any())">
            @(_saving ? "Saving..." : "Save this wanted list")
        </MudButton>

        <MudDivider Class="my-12" />

        @if (newListModel.Items.Any())
        {
            <MudTable Items="newListModel.Items"
                      Hover="true"
                      Striped="true"
                      Page="_itemsPage"
                      RowsPerPage="_itemsRowsPerPage"
                      OnPageChanged="OnItemsPageChanged"
                      OnRowsPerPageChanged="OnItemsRowsPerPageChanged">
                <HeaderContent>
                    <MudTh>Image</MudTh>
                    <MudTh>Brick</MudTh>
                    <MudTh>Color</MudTh>
                    <MudTh>Quantity</MudTh>
                    <MudTh></MudTh>
                </HeaderContent>

                <RowTemplate Context="item">
                    <MudTd DataLabel="Image">
                        @{
                            _brickById.TryGetValue(item.MappedBrickId, out var brick);

                            var colorName = brickColors.FirstOrDefault(c => c.Id == item.ColorId)?.Name;
                            var overlay = BrickColorHelper.GetHexForColor(colorName);
                            var overlayCss = overlay ?? "transparent";

                            var url = brick != null ? ImageService.GetMappedBrickImagePath(brick) : "/placeholder-image.png";
                            var hasImage = !string.IsNullOrWhiteSpace(url) && url != "/placeholder-image.png";
                        }

                        <div class="brick"
                             style="--brick-color:@overlayCss; width:32px; height:32px; min-width:32px; min-height:32px;">
                            <img src="@(hasImage ? url : "/placeholder-image.png")"
                                 alt=""
                                 class="brick-img"
                                 style="border-width:1px;@(hasImage ? "" : "opacity:0.5;")"
                                 onerror="if(this.src!=='/placeholder-image.png'){this.src='/placeholder-image.png';this.style.opacity='0.5';}" />
                        </div>
                    </MudTd>

                    <MudTd DataLabel="Brick">@item.BrickName</MudTd>
                    <MudTd DataLabel="Color">@brickColors.FirstOrDefault(c => c.Id == item.ColorId)?.Name</MudTd>
                    <MudTd DataLabel="Quantity">@item.Quantity</MudTd>
                    <MudTd>
                        <MudButton Variant="Variant.Outlined"
                                   Color="Color.Error"
                                   Size="Size.Small"
                                   OnClick="@(() => RemoveItem(item))"
                                   Class="ml-2">
                            Remove
                        </MudButton>
                    </MudTd>
                </RowTemplate>

                <PagerContent>
                    <MudTablePager PageSizeOptions="new int[] { 10, 25, 50, 100 }" />
                </PagerContent>
            </MudTable>
        }
    </EditForm>
</MudPaper>

<MudDivider Class="my-12" />

@if (_loading)
{
    <MudProgressCircular Indeterminate="true" />
    <MudText Typo="Typo.body2">Loading wanted lists…</MudText>
}
else if (_wantedListSummaries == null || !_wantedListSummaries.Any())
{
    <MudAlert Severity="Severity.Info">You do not have any wanted lists yet.</MudAlert>
}
else
{
    <MudTable Items="_wantedListSummaries" Hover="true" Striped="true">
        <HeaderContent>
            <MudTh>Name</MudTh>
            <MudTh>Items</MudTh>
            <MudTh>Action</MudTh>
        </HeaderContent>
        <RowTemplate Context="wl">
            <MudTd>
                <span style="cursor:pointer; color: #1976d2; font-size: 1.3rem; text-decoration: underline;"
                      @onclick="() => GoToDetails(wl.Id)">
                    @wl.Name
                </span>
                <div style="color:#777; font-size:0.9em;">Added from: @wl.Source</div>
            </MudTd>
            <MudTd>@wl.ItemCount</MudTd>
            <MudTd>
                <MudButton Variant="Variant.Outlined" Color="Color.Error" Size="Size.Small"
                           OnClick="@(() => RemoveWantedList(wl.Id))">
                    Remove
                </MudButton>
            </MudTd>
        </RowTemplate>
    </MudTable>
}

@code {
    // Overview ist jetzt super leicht
    private List<WantedListSummary>? _wantedListSummaries;

    private bool _loading = true;

    private string? _error;
    private string? _errorDetails;

    private void SetError(Exception ex, string? context = null)
    {
        _error = context == null
            ? $"An error happened: {ex.Message}"
            : $"An error happened ({context}): {ex.Message}";
        _errorDetails = ex.ToString();
    }

    // Search UX
    private int _searchRequestId = 0;
    private bool _searching = false;

    // Save UX
    private bool _saving = false;

    // Pagination (New list preview table)
    private int _itemsPage = 0;
    private int _itemsRowsPerPage = 25;

    private readonly Dictionary<int, MappedBrick> _brickById = new();

    private NewWantedListModel newListModel = new();
    private string brickSearchText = "";
    private List<MappedBrick> brickSearchResults = new();
    private MappedBrick? selectedBrick;
    private List<BrickColor> brickColors = new();
    private int? selectedColorId = null;
    private int brickQuantity = 1;

    // Lazy cache – wird erst geladen, wenn der User wirklich sucht
    private List<MappedBrick> _allBricks = new();
    private bool _allBricksLoaded = false;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            _loading = true;

            // parallel: Summaries + Colors
            var wantedTask = WantedListService.GetCurrentUserWantedListSummariesAsync();
            var colorsTask = MappedBrickService.GetAllColorsAsync();

            await Task.WhenAll(wantedTask, colorsTask);

            _wantedListSummaries = await wantedTask;
            brickColors = await colorsTask;

            // WICHTIG: _allBricks NICHT hier laden -> Performance!
        }
        catch (Exception ex)
        {
            SetError(ex, "OnInitializedAsync");
            _wantedListSummaries = new();
        }
        finally
        {
            _loading = false;
        }
    }

    private async Task EnsureAllBricksLoadedAsync()
    {
        if (_allBricksLoaded) return;
        _allBricksLoaded = true;

        try
        {
            // Diese Query ist schwer – deshalb lazy
            _allBricks = await MappedBrickService.GetAllMappedBricksAsync();

            foreach (var b in _allBricks)
                _brickById[b.Id] = b;
        }
        catch (Exception ex)
        {
            // wenn das fehlschlägt, soll die Seite nicht komplett sterben
            SetError(ex, "LoadAllBricks");
            _allBricks = new();
            _allBricksLoaded = false;
        }
    }

    private void OnItemsPageChanged(int page) => _itemsPage = page;

    private void OnItemsRowsPerPageChanged(int size)
    {
        _itemsRowsPerPage = size;
        _itemsPage = 0;
    }

    private void GoToDetails(int wantedListId)
        => Nav.NavigateTo($"/mywantedlistdetails/{wantedListId}");

    private async Task RemoveWantedList(int wantedListId)
    {
        try
        {
            await WantedListService.DeleteWantedListAsync(wantedListId);
            _wantedListSummaries = await WantedListService.GetCurrentUserWantedListSummariesAsync();
        }
        catch (Exception ex)
        {
            SetError(ex, "RemoveWantedList");
        }
        finally
        {
            StateHasChanged();
        }
    }

    private async Task OnBrickSearchChanged(string value)
    {
        brickSearchText = value ?? "";
        var reqId = ++_searchRequestId;

        if (brickSearchText.Length < 2)
        {
            brickSearchResults.Clear();
            _searching = false;
            await InvokeAsync(StateHasChanged);
            return;
        }

        _searching = true;
        await InvokeAsync(StateHasChanged);

        try
        {
            // Lazy load – erst jetzt
            await EnsureAllBricksLoadedAsync();

            if (reqId != _searchRequestId) return;

            brickSearchResults = _allBricks
                .Where(b =>
                    (b.LegoPartNum?.Contains(brickSearchText, StringComparison.OrdinalIgnoreCase) ?? false) ||
                    (b.LegoName?.Contains(brickSearchText, StringComparison.OrdinalIgnoreCase) ?? false) ||
                    (b.Name?.Contains(brickSearchText, StringComparison.OrdinalIgnoreCase) ?? false))
                .Take(10)
                .ToList();
        }
        catch (Exception ex)
        {
            SetError(ex, "OnBrickSearchChanged");
        }
        finally
        {
            if (reqId == _searchRequestId)
            {
                _searching = false;
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    private void SelectBrick(MappedBrick brick)
    {
        _searchRequestId++;

        selectedBrick = brick;
        selectedColorId = null;
        brickQuantity = 1;

        brickSearchResults.Clear();
        brickSearchText = brick.LegoPartNum ?? brick.Name ?? "";

        _searching = false;
        StateHasChanged();
    }

    private void AddBrickToList()
    {
        if (selectedBrick == null || selectedColorId == null || brickQuantity < 1)
            return;

        _brickById[selectedBrick.Id] = selectedBrick;

        AddOrMergeItem(newListModel.Items, new NewWantedListItemModel
        {
            MappedBrickId = selectedBrick.Id,
            BrickName = selectedBrick.Name,
            ColorId = selectedColorId.Value,
            Quantity = brickQuantity
        });

        // reset inputs
        selectedBrick = null;
        selectedColorId = null;
        brickQuantity = 1;
        brickSearchText = "";

        _itemsPage = 0;
        StateHasChanged();
    }

    private void RemoveItem(NewWantedListItemModel item)
    {
        newListModel.Items.Remove(item);
        _itemsPage = 0;
        StateHasChanged();
    }

    private async Task HandleCreateWantedList()
    {
        if (_saving) return;
        if (string.IsNullOrWhiteSpace(newListModel.Name) || !newListModel.Items.Any())
            return;

        _saving = true;
        if (newListModel.UnmappedRows.Count > 0)
        {
            LoadingService.Show("Saving wanted list and inform admin about missing items...");

        }
        else
        {
            LoadingService.Show("Saving wanted list...");
        }

        try
        {
            var wantedListId = await WantedListService.CreateWantedListAndReturnIdAsync(newListModel);
            if (wantedListId > 0)
            {
                NotificationService.Success("Wanted list created.");
                Nav.NavigateTo($"/mywantedlistdetails/{wantedListId}");
            }
        }
        catch (Exception ex)
        {
            SetError(ex, "HandleCreateWantedList");
            NotificationService.Error(_error ?? "An error happened.");
        }
        finally
        {
            LoadingService.Hide();
            _saving = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    // =========================
    // ===== Upload (zentral) ===
    // =========================

    private Task OnUploadParsed(ParseResult<ParsedPart> result)
    {
        newListModel.UnmappedRows = result.Unmapped;

        // Source sauber normalisieren (trim/lower/csv/xml weg)
        newListModel.Source = WantedListService.NormalizeSource(result.AppliedFormat.ToString());

        return Task.CompletedTask;
    }

    private async void AddUploadItemsToNewList_FromComponent(List<ParsedPart> parts)
{
    LoadingService.Show("Adding uploaded items to wanted list...");
        await EnsureAllBricksLoadedAsync(); 

    foreach (var p in parts)
    {
        _brickById.TryGetValue(p.MappedBrickId, out var brick);
        AddOrMergeItem(newListModel.Items, new NewWantedListItemModel
        {
            MappedBrickId = p.MappedBrickId,
            BrickName = brick?.Name ?? $"Brick #{p.MappedBrickId}",
            ColorId = p.BrickColorId,
            Quantity = p.Quantity
        });
    }
LoadingService.Hide();
        _itemsPage = 0;
        NotificationService.Success("Upload items added to list.");
        StateHasChanged();
    }

    private Task OnUploadCleared()
    {
        // optional: newListModel.UnmappedRows = new();
        return Task.CompletedTask;
    }

    private static void AddOrMergeItem(List<NewWantedListItemModel> list, NewWantedListItemModel item)
    {
        var existing = list.FirstOrDefault(x => x.MappedBrickId == item.MappedBrickId && x.ColorId == item.ColorId);
        if (existing != null)
        {
            existing.Quantity += item.Quantity;
            return;
        }
        list.Add(item);
    }
}
