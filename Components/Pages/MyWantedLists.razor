@page "/mywantedlists"

@using Data.Entities
@using Data.Services
@using Data.DTOs
@using Helpers

@inject WantedListService WantedListService
@inject Services.MappedBrickService MappedBrickService
@inject Data.Services.ImageService ImageService
@inject NavigationManager Nav

<PageTitle>My Wanted Lists</PageTitle>

<MudText Typo="Typo.h4" GutterBottom="true">My Wanted Lists</MudText>

<style>
    .brick {
        position: relative;
        display: inline-block;
        width: 56px;
        height: 56px;
        min-width: 56px;
        min-height: 56px;
        box-sizing: border-box;
    }

    .brick-img {
        width: 100%;
        height: 100%;
        object-fit: contain;
        border-radius: 4px;
        border: 2px solid #ccc;
        background: #fff;
        display: block;
    }

    .brick::after {
        content: "";
        position: absolute;
        right: .5px;
        bottom: 0px;
        width: 0;
        height: 0;
        border-bottom: 28px solid var(--brick-color, transparent);
        border-left: 28px solid transparent;
        border-radius: 0 0 4px 0;
        z-index: 2;
        pointer-events: none;
    }
</style>

@if (_loading)
{
    <MudProgressCircular Indeterminate="true" />
}
else if (_wantedLists == null || !_wantedLists.Any())
{
    <MudAlert Severity="Severity.Info">You do not have any wanted lists yet.</MudAlert>
}
else
{

    <MudTable Items="_wantedLists" Hover="true" Striped="true">
        <HeaderContent>
            <MudTh>Name</MudTh>
            <MudTh>Items</MudTh>
            <MudTh>Action</MudTh>
        </HeaderContent>
        <RowTemplate Context="wl">
            <MudTd>
                <span style="cursor:pointer; color: #1976d2; text-decoration: underline;" @onclick="() => GoToDetails(wl.Id)">@wl.Name</span>
            </MudTd>
            <MudTd>@wl.Items.Count</MudTd>
            <MudTd>
                <MudButton Variant="Variant.Outlined" Color="Color.Error" Size="Size.Small" OnClick="@(() => RemoveWantedList(wl.Id))">Remove</MudButton>
            </MudTd>
        </RowTemplate>
    </MudTable>

}
<MudPaper Class="pa-4 mt-6">
        <MudText Typo="Typo.h6" GutterBottom="true">Create new wanted list</MudText>

        <EditForm Model="newListModel" OnValidSubmit="HandleCreateWantedList">
            <MudTextField @bind-Value="newListModel.Name" Label="List name" Required="true" Class="mb-2" />

            <MudDivider Class="my-2" />
            <MudText Typo="Typo.body1" GutterBottom="true" Style="font-weight:bold;">Add items</MudText>

            <MudTextField T="string"
            Value="@brickSearchText"
            ValueChanged="OnBrickSearchChanged"
            Immediate="true"
            Label="Search brick"
            Class="mb-2" />

            @if (_searching)
            {
                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2" Class="mb-2">
                    <MudProgressCircular Indeterminate="true" Size="Size.Small" />
                    <MudText Typo="Typo.body2">Grabbing all items</MudText>
                </MudStack>
            }

            @if (brickSearchResults.Any())
            {
                <MudList T="MappedBrick">
                    @foreach (var brick in brickSearchResults)
                    {
                        <MudListItem T="MappedBrick"
                        Style="cursor:pointer;display:flex;align-items:center;"
                        OnClick="@(() => SelectBrick(brick))">

                            <img src="@ImageService.GetMappedBrickImagePath(brick)" alt=""
                            style="width:32px;height:32px;object-fit:contain;margin-right:8px;vertical-align:middle;border-radius:4px;border:1px solid #ccc;" />
                            @brick.Name (@brick.LegoPartNum)
                        </MudListItem>
                    }
                </MudList>
            }

            @if (selectedBrick != null)
            {
                <div style="margin-bottom:8px;display:flex;align-items:center;">
                    @{
                        var selectedColorName = selectedColorId.HasValue
                                        ? brickColors.FirstOrDefault(c => c.Id == selectedColorId.Value)?.Name
                                        : null;

                        var overlay = BrickColorHelper.GetHexForColor(selectedColorName);
                        var overlayCss = overlay ?? "transparent";

                        var url = ImageService.GetMappedBrickImagePath(selectedBrick);
                        var hasImage = !string.IsNullOrWhiteSpace(url) && url != "/placeholder-image.png";
                    }

                    <div class="brick" style="--brick-color:@overlayCss; width:48px; height:48px; min-width:48px; min-height:48px; margin-right:8px;">
                        <img src="@(hasImage ? url : "/placeholder-image.png")"
                        alt=""
                        class="brick-img"
                        style="border-width:1px;@(hasImage ? "" : "opacity:0.5;")"
                        onerror="if(this.src!=='/placeholder-image.png'){this.src='/placeholder-image.png';this.style.opacity='0.5';}" />
                    </div>

                    <span style="font-weight:500;">
                        @selectedBrick.Name
                        @if (!string.IsNullOrWhiteSpace(selectedBrick.LegoPartNum))
                        {
                            <span style="color:#888;">(@selectedBrick.LegoPartNum)</span>
                        }
                    </span>
                </div>

                <!-- FIX: nullable int? + Placeholder (kein "0") -->
                <MudSelect T="int?"
                @bind-Value="selectedColorId"
                Label="Color"
                Placeholder="Please select a color"
                Variant="Variant.Text"
                Dense="true"
                Class="mb-2"
                Style="max-width:300px;">
                    @foreach (var color in brickColors)
                    {
                        <MudSelectItem T="int?" Value="@color.Id">@color.Name</MudSelectItem>
                    }
                </MudSelect>

                <MudNumericField T="int"
                @bind-Value="brickQuantity"
                Label="Quantity"
                Min="1"
                Max="999"
                Variant="Variant.Text"
                Dense="true"
                Class="mb-2"
                Style="max-width:300px;" />

                <MudButton Variant="Variant.Filled"
                Color="Color.Primary"
                OnClick="AddBrickToList"
                Disabled="@(selectedColorId is null)"
                Class="mb-2">
                    Add item
                </MudButton>
                <br>
            }

            @if (newListModel.Items.Any())
            {
                <MudTable Items="newListModel.Items" Hover="true" Striped="true">
                    <HeaderContent>
                        <MudTh>Image</MudTh>
                        <MudTh>Brick</MudTh>
                        <MudTh>Color</MudTh>
                        <MudTh>Quantity</MudTh>
                        <MudTh></MudTh>
                    </HeaderContent>

                    <RowTemplate Context="item">
                        <MudTd DataLabel="Image">
                            @{
                                _brickById.TryGetValue(item.MappedBrickId, out var brick);

                                var colorName = brickColors.FirstOrDefault(c => c.Id == item.ColorId)?.Name;
                                var overlay = BrickColorHelper.GetHexForColor(colorName);
                                var overlayCss = overlay ?? "transparent";

                                var url = brick != null ? ImageService.GetMappedBrickImagePath(brick) : "/placeholder-image.png";
                                var hasImage = !string.IsNullOrWhiteSpace(url) && url != "/placeholder-image.png";
                            }

                            <div class="brick" style="--brick-color:@overlayCss; width:32px; height:32px; min-width:32px; min-height:32px;">
                                <img src="@(hasImage ? url : "/placeholder-image.png")"
                                alt=""
                                class="brick-img"
                                style="border-width:1px;@(hasImage ? "" : "opacity:0.5;")"
                                onerror="if(this.src!=='/placeholder-image.png'){this.src='/placeholder-image.png';this.style.opacity='0.5';}" />
                            </div>
                        </MudTd>

                        <MudTd DataLabel="Brick">@item.BrickName</MudTd>
                        <MudTd DataLabel="Color">@brickColors.FirstOrDefault(c => c.Id == item.ColorId)?.Name</MudTd>
                        <MudTd DataLabel="Quantity">@item.Quantity</MudTd>
                        <MudTd>
                            <MudButton Variant="Variant.Outlined" Color="Color.Error" Size="Size.Small"
                            OnClick="@(() => RemoveItem(item))"
                            Class="ml-2">
                                Remove
                            </MudButton>
                        </MudTd>
                    </RowTemplate>
                </MudTable>
            }

            <!-- FIX: echter Submit -->
            <MudButton Variant="Variant.Filled"
            Color="Color.Success"
            ButtonType="ButtonType.Submit"
            Disabled="@_saving"
            Class="mt-3">
                @(_saving ? "Saving..." : "Save wanted list")
            </MudButton>
        </EditForm>
    </MudPaper>

    @code {
    private List<WantedList>? _wantedLists;
    private bool _loading = true;
    private int _searchRequestId = 0;

    private bool _searching = false;
    private bool _saving = false;

    // Cache für Bildanzeige in der Added-Items Tabelle
    private readonly Dictionary<int, MappedBrick> _brickById = new();

    // Für neue Liste
    private NewWantedListModel newListModel = new();
    private string brickSearchText = "";
    private List<MappedBrick> brickSearchResults = new();
    private MappedBrick? selectedBrick;
    private List<BrickColor> brickColors = new();

    // FIX: nullable int? statt int (kein "0")
    private int? selectedColorId = null;

    private int brickQuantity = 1;

    protected override async Task OnInitializedAsync()
    {
        _loading = true;
        _wantedLists = await WantedListService.GetCurrentUserWantedListsAsync();
        brickColors = await MappedBrickService.GetAllColorsAsync();
        _loading = false;
    }

    private void GoToDetails(int wantedListId)
    {
        Nav.NavigateTo($"/mywantedlistdetails/{wantedListId}");
    }

   private async Task OnBrickSearchChanged(string value)
{
    brickSearchText = value ?? "";

    // neue Request-ID (alles davor ist "alt")
    var reqId = ++_searchRequestId;

    if (brickSearchText.Length < 2)
    {
        brickSearchResults.Clear();
        _searching = false;
        await InvokeAsync(StateHasChanged);
        return;
    }

    _searching = true;
    await InvokeAsync(StateHasChanged);

    try
    {
        var allBricks = await MappedBrickService.GetAllMappedBricksAsync();

        // Wenn inzwischen schon eine neuere Suche gestartet wurde: Ergebnis ignorieren
        if (reqId != _searchRequestId) return;

        brickSearchResults = allBricks
            .Where(b =>
                (b.LegoPartNum?.Contains(brickSearchText, StringComparison.OrdinalIgnoreCase) ?? false) ||
                (b.LegoName?.Contains(brickSearchText, StringComparison.OrdinalIgnoreCase) ?? false) ||
                (b.Name?.Contains(brickSearchText, StringComparison.OrdinalIgnoreCase) ?? false))
            .Take(10)
            .ToList();
    }
    finally
    {
        // Auch hier nur updaten, wenn das noch die aktuelle Suche ist
        if (reqId == _searchRequestId)
        {
            _searching = false;
            await InvokeAsync(StateHasChanged);
        }
    }
}

    private async Task RemoveWantedList(int wantedListId)
    {
        await WantedListService.DeleteWantedListAsync(wantedListId);
        _wantedLists = await WantedListService.GetCurrentUserWantedListsAsync();
        StateHasChanged();
    }

    private void SelectBrick(MappedBrick brick)
{
    // laufende/ausstehende Suche ungültig machen
    _searchRequestId++;

    selectedBrick = brick;
    selectedColorId = null;
    brickQuantity = 1;

    brickSearchResults.Clear();
    brickSearchText = brick.LegoPartNum ?? brick.Name ?? "";

    _searching = false;
    StateHasChanged();
}


    private void AddBrickToList()
    {
        if (selectedBrick == null || selectedColorId == null || brickQuantity < 1)
            return;

        _brickById[selectedBrick.Id] = selectedBrick;

        newListModel.Items.Add(new NewWantedListItemModel
        {
            MappedBrickId = selectedBrick.Id,
            BrickName = selectedBrick.Name,
            ColorId = selectedColorId.Value,
            Quantity = brickQuantity
        });

        selectedBrick = null;
        selectedColorId = null;
        brickQuantity = 1;
        brickSearchText = "";
        StateHasChanged();
    }

    private void RemoveItem(NewWantedListItemModel item)
    {
        newListModel.Items.Remove(item);
        StateHasChanged();
    }

    // FIX: Speichern + Redirect zur Detailseite
    private async Task HandleCreateWantedList()
    {
        if (_saving) return;
        if (string.IsNullOrWhiteSpace(newListModel.Name) || !newListModel.Items.Any())
            return;

        _saving = true;
        try
        {
            var wantedListId = await WantedListService.CreateWantedListAndReturnIdAsync(newListModel);
            if (wantedListId > 0)
            {
                Nav.NavigateTo($"/mywantedlistdetails/{wantedListId}");
            }
        }
        finally
        {
            _saving = false;
            await InvokeAsync(StateHasChanged);
        }
    }
}
