@page "/mywantedlists"

@using Data.Entities
@using Data.Services
@using Data.DTOs
@using Helpers
@using System.Xml.Linq
@using Microsoft.AspNetCore.Components.Forms
@using IBrowserFile = Microsoft.AspNetCore.Components.Forms.IBrowserFile

@inject WantedListService WantedListService
@inject Services.MappedBrickService MappedBrickService
@inject Data.Services.ImageService ImageService
@inject NavigationManager Nav
@inject Services.LoadingService LoadingService
@inject Services.NotificationService NotificationService

<PageTitle>My Wanted Lists</PageTitle>

<MudText Typo="Typo.h4" GutterBottom="true">My Wanted Lists</MudText>

@if (!string.IsNullOrWhiteSpace(_error))
{
    <MudAlert Severity="Severity.Error" Variant="Variant.Filled" Class="mb-4">
        @_error
        @if (!string.IsNullOrWhiteSpace(_errorDetails))
        {
            <MudDivider Class="my-2" />
            <MudText Typo="Typo.caption" Style="white-space:pre-wrap;">@_errorDetails</MudText>
        }
    </MudAlert>
}

<style>
    .brick {
        position: relative;
        display: inline-block;
        width: 56px;
        height: 56px;
        min-width: 56px;
        min-height: 56px;
        box-sizing: border-box;
    }

    .brick-img {
        width: 100%;
        height: 100%;
        object-fit: contain;
        border-radius: 4px;
        border: 2px solid #ccc;
        background: #fff;
        display: block;
    }

    .brick::after {
        content: "";
        position: absolute;
        right: .5px;
        bottom: 0px;
        width: 0;
        height: 0;
        border-bottom: 28px solid var(--brick-color, transparent);
        border-left: 28px solid transparent;
        border-radius: 0 0 4px 0;
        z-index: 2;
        pointer-events: none;
    }
</style>

@if (_loading)
{
    <MudProgressCircular Indeterminate="true" />
}
else if (_wantedLists == null || !_wantedLists.Any())
{
    <MudAlert Severity="Severity.Info">You do not have any wanted lists yet.</MudAlert>
}
else
{
    <MudTable Items="_wantedLists" Hover="true" Striped="true">
        <HeaderContent>
            <MudTh>Name</MudTh>
            <MudTh>Items</MudTh>
            <MudTh>Action</MudTh>
        </HeaderContent>
        <RowTemplate Context="wl">
            <MudTd>
                <span style="cursor:pointer; color: #1976d2; text-decoration: underline;" @onclick="() => GoToDetails(wl.Id)">
                    @wl.Name
                </span>
            </MudTd>
            <MudTd>@wl.Items.Count</MudTd>
            <MudTd>
                <MudButton Variant="Variant.Outlined" Color="Color.Error" Size="Size.Small" OnClick="@(() => RemoveWantedList(wl.Id))">
                    Remove
                </MudButton>
            </MudTd>
        </RowTemplate>
    </MudTable>
}

<MudPaper Class="pa-4 mt-6">
    <MudText Typo="Typo.h6" GutterBottom="true">Create new wanted list</MudText>

    <EditForm Model="newListModel" OnValidSubmit="HandleCreateWantedList">
        <MudTextField @bind-Value="newListModel.Name" Label="List name" Required="true" Class="mb-2" />

        <MudDivider Class="my-2" />

        <!-- UPLOAD -->
        <MudText Typo="Typo.body1" GutterBottom="true" Style="font-weight:bold;">Upload wanted list file</MudText>
        <MudText Typo="Typo.caption" Class="mb-2" Style="color:#666;">
            Choose the exact format you upload. We validate structure and show unmapped parts / invalid color IDs (those rows are ignored).
        </MudText>

        <MudSelect T="string"
                   @bind-Value="_selectedUploadFormat"
                   Label="Upload format"
                   Dense="true"
                   Disabled="@_uploading"
                   Style="max-width:360px;">
            <MudSelectItem Value="@UploadFormats.RebrickableCsv">Rebrickable CSV (Part,Color,Quantity)</MudSelectItem>
            <MudSelectItem Value="@UploadFormats.RebrickableXml">Rebrickable XML</MudSelectItem>
            <MudSelectItem Value="@UploadFormats.BricklinkXml">BrickLink XML</MudSelectItem>
        </MudSelect>

        <InputFile OnChange="OnWantedFileSelected"
                   accept=".csv,.xml"
                   disabled="@(_uploading || string.IsNullOrWhiteSpace(_selectedUploadFormat))"
                   class="mt-2" />

        @if (!string.IsNullOrWhiteSpace(_uploadError))
        {
            <MudAlert Severity="Severity.Error" Class="mt-2">@_uploadError</MudAlert>
        }

        @if (_uploadParsedItems.Count > 0)
        {
            <MudAlert Severity="Severity.Success" Class="mt-3">
                Upload parsed: @_uploadParsedItems.Count item(s) ready to add.
            </MudAlert>
        }

        @if (_unmappedUploadItems.Count > 0)
        {
            <MudAlert Severity="Severity.Warning" Class="mt-3">
                Unmapped parts: @_unmappedUploadItems.Count (no MappedBrick found by PartNum). These rows are ignored.
            </MudAlert>

            <MudExpansionPanels>
                <MudExpansionPanel Text="Show unmapped items" Expanded="false" MaxHeight="450">
                    <MudPaper Class="pa-2 mb-2" Style="background:#fffbe6;border:1px solid #ffe082;">
                        <MudList T="string">
                            @foreach (var item in _unmappedUploadItems)
                            {
                                <MudListItem T="string">
                                    <MudText>Part: <b>@item.PartNum</b>, ColorId: <b>@item.ColorId</b>, Qty: <b>@item.Quantity</b></MudText>
                                </MudListItem>
                            }
                        </MudList>
                    </MudPaper>
                </MudExpansionPanel>
            </MudExpansionPanels>
        }

        @if (_invalidUploadColorIds.Count > 0)
        {
            <MudAlert Severity="Severity.Error" Class="mt-3">
                Invalid ColorId(s) in upload: <b>@string.Join(", ", _invalidUploadColorIds.OrderBy(x => x))</b>.
                These rows are ignored. Fix your file or seed missing colors / mappings.
            </MudAlert>
        }

        @if (_invalidUploadRows.Count > 0)
        {
            <MudExpansionPanels>
                <MudExpansionPanel Text="Show invalid rows (details)" Expanded="false" MaxHeight="450">
                    <MudPaper Class="pa-2 mb-2" Style="background:#fff5f5;border:1px solid #ffcdd2;">
                        <MudList T="string">
                            @foreach (var r in _invalidUploadRows.Take(500))
                            {
                                <MudListItem T="string">
                                    <MudText>
                                        Part: <b>@r.PartNum</b>,
                                        ColorId: <b>@r.ColorId</b>,
                                        Qty: <b>@r.Qty</b>
                                        <span style="color:#888">— @r.Reason</span>
                                    </MudText>
                                </MudListItem>
                            }
                        </MudList>
                    </MudPaper>
                </MudExpansionPanel>
            </MudExpansionPanels>
        }

        @if (_uploadParsedItems.Count > 0)
        {
            <MudStack Row="true" Spacing="2" Class="mt-2 mb-4">
                <MudButton Variant="Variant.Filled"
                           Color="Color.Primary"
                           OnClick="AddUploadItemsToNewList"
                           Disabled="@(_saving || _uploadParsedItems.Count == 0)">
                    Add upload items to list
                </MudButton>
                <MudButton Variant="Variant.Outlined"
                           Color="Color.Secondary"
                           OnClick="ClearUpload"
                           Disabled="@_saving">
                    Clear upload
                </MudButton>
            </MudStack>
        }

        <MudDivider Class="my-2" />

        <!-- MANUAL ADD -->
        <MudText Typo="Typo.body1" GutterBottom="true" Style="font-weight:bold;">Add items manually</MudText>

        <MudTextField T="string"
                      Value="@brickSearchText"
                      ValueChanged="OnBrickSearchChanged"
                      Immediate="true"
                      Label="Search brick"
                      Class="mb-2" />

        @if (_searching)
        {
            <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2" Class="mb-2">
                <MudProgressCircular Indeterminate="true" Size="Size.Small" />
                <MudText Typo="Typo.body2">Searching…</MudText>
            </MudStack>
        }

        @if (brickSearchResults.Any())
        {
            <MudList T="MappedBrick">
                @foreach (var brick in brickSearchResults)
                {
                    <MudListItem T="MappedBrick"
                                 Style="cursor:pointer;display:flex;align-items:center;"
                                 OnClick="@(() => SelectBrick(brick))">
                        <img src="@ImageService.GetMappedBrickImagePath(brick)" alt=""
                             style="width:32px;height:32px;object-fit:contain;margin-right:8px;vertical-align:middle;border-radius:4px;border:1px solid #ccc;" />
                        @brick.Name (@brick.LegoPartNum)
                    </MudListItem>
                }
            </MudList>
        }

        @if (selectedBrick != null)
        {
            <div style="margin-bottom:8px;display:flex;align-items:center;">
                @{
                    var selectedColorName = selectedColorId.HasValue
                        ? brickColors.FirstOrDefault(c => c.Id == selectedColorId.Value)?.Name
                        : null;

                    var overlay = BrickColorHelper.GetHexForColor(selectedColorName);
                    var overlayCss = overlay ?? "transparent";

                    var url = ImageService.GetMappedBrickImagePath(selectedBrick);
                    var hasImage = !string.IsNullOrWhiteSpace(url) && url != "/placeholder-image.png";
                }

                <div class="brick" style="--brick-color:@overlayCss; width:48px; height:48px; min-width:48px; min-height:48px; margin-right:8px;">
                    <img src="@(hasImage ? url : "/placeholder-image.png")"
                         alt=""
                         class="brick-img"
                         style="border-width:1px;@(hasImage ? "" : "opacity:0.5;")"
                         onerror="if(this.src!=='/placeholder-image.png'){this.src='/placeholder-image.png';this.style.opacity='0.5';}" />
                </div>

                <span style="font-weight:500;">
                    @selectedBrick.Name
                    @if (!string.IsNullOrWhiteSpace(selectedBrick.LegoPartNum))
                    {
                        <span style="color:#888;">(@selectedBrick.LegoPartNum)</span>
                    }
                </span>
            </div>

            <MudSelect T="int?"
                       @bind-Value="selectedColorId"
                       Label="Color"
                       Placeholder="Please select a color"
                       Variant="Variant.Text"
                       Dense="true"
                       Class="mb-2"
                       Style="max-width:300px;">
                @foreach (var color in brickColors)
                {
                    <MudSelectItem T="int?" Value="@color.Id">@color.Name</MudSelectItem>
                }
            </MudSelect>

            <MudNumericField T="int"
                             @bind-Value="brickQuantity"
                             Label="Quantity"
                             Min="1"
                             Max="999"
                             Variant="Variant.Text"
                             Dense="true"
                             Class="mb-2"
                             Style="max-width:300px;" />

            <MudButton Variant="Variant.Filled"
                       Color="Color.Primary"
                       OnClick="AddBrickToList"
                       Disabled="@(selectedColorId is null)"
                       Class="mb-2">
                Add item
            </MudButton>
            <br />
        }

        @if (newListModel.Items.Any())
        {
            <MudTable Items="newListModel.Items" Hover="true" Striped="true">
                <HeaderContent>
                    <MudTh>Image</MudTh>
                    <MudTh>Brick</MudTh>
                    <MudTh>Color</MudTh>
                    <MudTh>Quantity</MudTh>
                    <MudTh></MudTh>
                </HeaderContent>

                <RowTemplate Context="item">
                    <MudTd DataLabel="Image">
                        @{
                            _brickById.TryGetValue(item.MappedBrickId, out var brick);

                            var colorName = brickColors.FirstOrDefault(c => c.Id == item.ColorId)?.Name;
                            var overlay = BrickColorHelper.GetHexForColor(colorName);
                            var overlayCss = overlay ?? "transparent";

                            var url = brick != null ? ImageService.GetMappedBrickImagePath(brick) : "/placeholder-image.png";
                            var hasImage = !string.IsNullOrWhiteSpace(url) && url != "/placeholder-image.png";
                        }

                        <div class="brick" style="--brick-color:@overlayCss; width:32px; height:32px; min-width:32px; min-height:32px;">
                            <img src="@(hasImage ? url : "/placeholder-image.png")"
                                 alt=""
                                 class="brick-img"
                                 style="border-width:1px;@(hasImage ? "" : "opacity:0.5;")"
                                 onerror="if(this.src!=='/placeholder-image.png'){this.src='/placeholder-image.png';this.style.opacity='0.5';}" />
                        </div>
                    </MudTd>

                    <MudTd DataLabel="Brick">@item.BrickName</MudTd>
                    <MudTd DataLabel="Color">@brickColors.FirstOrDefault(c => c.Id == item.ColorId)?.Name</MudTd>
                    <MudTd DataLabel="Quantity">@item.Quantity</MudTd>
                    <MudTd>
                        <MudButton Variant="Variant.Outlined" Color="Color.Error" Size="Size.Small"
                                   OnClick="@(() => RemoveItem(item))"
                                   Class="ml-2">
                            Remove
                        </MudButton>
                    </MudTd>
                </RowTemplate>
            </MudTable>
        }

        <MudButton Variant="Variant.Filled"
                   Color="Color.Success"
                   ButtonType="ButtonType.Submit"
                   Disabled="@_saving"
                   Class="mt-3">
            @(_saving ? "Saving..." : "Save wanted list")
        </MudButton>
    </EditForm>
</MudPaper>

@code {
    private List<WantedList>? _wantedLists;
    private bool _loading = true;

    private string? _error;
    private string? _errorDetails;
    private void SetError(Exception ex, string? context = null)
    {
        _error = context == null
            ? $"An error happened: {ex.Message}"
            : $"An error happened ({context}): {ex.Message}";
        _errorDetails = ex.ToString();
    }

    private int _searchRequestId = 0;
    private bool _searching = false;
    private bool _saving = false;

    private readonly Dictionary<int, MappedBrick> _brickById = new();

    private NewWantedListModel newListModel = new();
    private string brickSearchText = "";
    private List<MappedBrick> brickSearchResults = new();
    private MappedBrick? selectedBrick;
    private List<BrickColor> brickColors = new();
    private int? selectedColorId = null;
    private int brickQuantity = 1;

    // Upload state
    private bool _uploading = false;
    private IBrowserFile? _uploadedWantedFile;
    private string _uploadError = "";

    private List<NewWantedListItemModel> _uploadParsedItems = new();
    private List<(string? PartNum, int? ColorId, int Quantity)> _unmappedUploadItems = new();

    private HashSet<int> _invalidUploadColorIds = new();
    private List<(string? PartNum, int? ColorId, int Qty, string Reason)> _invalidUploadRows = new();

    // For fast part lookup
    private Dictionary<string, MappedBrick> _brickByLegoPartNum = new(StringComparer.OrdinalIgnoreCase);

    // Color mapping caches
    private Dictionary<int, int> _rebrickableColorIdToBrickColorId = new();
    private Dictionary<string, int> _brickColorNameToBrickColorId = new(StringComparer.OrdinalIgnoreCase);

    private static class UploadFormats
    {
        public const string RebrickableCsv = "rebrickable_csv";
        public const string RebrickableXml = "rebrickable_xml";
        public const string BricklinkXml = "bricklink_xml";
    }

    private string _selectedUploadFormat = UploadFormats.RebrickableCsv;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            _loading = true;

            _wantedLists = await WantedListService.GetCurrentUserWantedListsAsync();
            brickColors = await MappedBrickService.GetAllColorsAsync();

            // Build color maps
            _rebrickableColorIdToBrickColorId = brickColors
                .GroupBy(c => c.RebrickableColorId)
                .ToDictionary(g => g.Key, g => g.First().Id);

            _brickColorNameToBrickColorId = brickColors
                .Where(c => !string.IsNullOrWhiteSpace(c.Name))
                .GroupBy(c => c.Name!, StringComparer.OrdinalIgnoreCase)
                .ToDictionary(g => g.Key, g => g.First().Id, StringComparer.OrdinalIgnoreCase);

            // einmal laden für schnelles Mapping
            var allBricks = await MappedBrickService.GetAllMappedBricksAsync();
            _brickByLegoPartNum = allBricks
                .Where(b => !string.IsNullOrWhiteSpace(b.LegoPartNum))
                .GroupBy(b => b.LegoPartNum!)
                .ToDictionary(g => g.Key, g => g.First(), StringComparer.OrdinalIgnoreCase);
        }
        catch (Exception ex)
        {
            SetError(ex, "OnInitializedAsync");
            _wantedLists = new();
        }
        finally
        {
            _loading = false;
        }
    }

    private void GoToDetails(int wantedListId)
        => Nav.NavigateTo($"/mywantedlistdetails/{wantedListId}");

    private async Task RemoveWantedList(int wantedListId)
    {
        try
        {
            await WantedListService.DeleteWantedListAsync(wantedListId);
            _wantedLists = await WantedListService.GetCurrentUserWantedListsAsync();
        }
        catch (Exception ex)
        {
            SetError(ex, "RemoveWantedList");
        }
        finally
        {
            StateHasChanged();
        }
    }

    private async Task OnBrickSearchChanged(string value)
    {
        brickSearchText = value ?? "";
        var reqId = ++_searchRequestId;

        if (brickSearchText.Length < 2)
        {
            brickSearchResults.Clear();
            _searching = false;
            await InvokeAsync(StateHasChanged);
            return;
        }

        _searching = true;
        await InvokeAsync(StateHasChanged);

        try
        {
            var allBricks = await MappedBrickService.GetAllMappedBricksAsync();
            if (reqId != _searchRequestId) return;

            brickSearchResults = allBricks
                .Where(b =>
                    (b.LegoPartNum?.Contains(brickSearchText, StringComparison.OrdinalIgnoreCase) ?? false) ||
                    (b.LegoName?.Contains(brickSearchText, StringComparison.OrdinalIgnoreCase) ?? false) ||
                    (b.Name?.Contains(brickSearchText, StringComparison.OrdinalIgnoreCase) ?? false))
                .Take(10)
                .ToList();
        }
        catch (Exception ex)
        {
            SetError(ex, "OnBrickSearchChanged");
        }
        finally
        {
            if (reqId == _searchRequestId)
            {
                _searching = false;
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    private void SelectBrick(MappedBrick brick)
    {
        _searchRequestId++;

        selectedBrick = brick;
        selectedColorId = null;
        brickQuantity = 1;

        brickSearchResults.Clear();
        brickSearchText = brick.LegoPartNum ?? brick.Name ?? "";

        _searching = false;
        StateHasChanged();
    }

    private void AddBrickToList()
    {
        if (selectedBrick == null || selectedColorId == null || brickQuantity < 1)
            return;

        _brickById[selectedBrick.Id] = selectedBrick;

        AddOrMergeItem(newListModel.Items, new NewWantedListItemModel
        {
            MappedBrickId = selectedBrick.Id,
            BrickName = selectedBrick.Name,
            ColorId = selectedColorId.Value,
            Quantity = brickQuantity
        });

        selectedBrick = null;
        selectedColorId = null;
        brickQuantity = 1;
        brickSearchText = "";
        StateHasChanged();
    }

    private void RemoveItem(NewWantedListItemModel item)
    {
        newListModel.Items.Remove(item);
        StateHasChanged();
    }

    private async Task HandleCreateWantedList()
    {
        if (_saving) return;
        if (string.IsNullOrWhiteSpace(newListModel.Name) || !newListModel.Items.Any())
            return;

        _saving = true;
        LoadingService.Show("Saving wanted list...");

        try
        {
            var wantedListId = await WantedListService.CreateWantedListAndReturnIdAsync(newListModel);
            if (wantedListId > 0)
            {
                NotificationService.Success("Wanted list created.");
                Nav.NavigateTo($"/mywantedlistdetails/{wantedListId}");
            }
        }
        catch (Exception ex)
        {
            SetError(ex, "HandleCreateWantedList");
            NotificationService.Error(_error);
        }
        finally
        {
            LoadingService.Hide();
            _saving = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    // =========================
    // ===== UPLOAD LOGIC ======
    // =========================

    private async Task OnWantedFileSelected(InputFileChangeEventArgs e)
    {
        if (_uploading) return;

        _uploadedWantedFile = e.File;
        _uploadError = "";
        _uploadParsedItems.Clear();
        _unmappedUploadItems.Clear();
        _invalidUploadColorIds.Clear();
        _invalidUploadRows.Clear();

        if (_uploadedWantedFile == null)
            return;

        if (string.IsNullOrWhiteSpace(_selectedUploadFormat))
        {
            _uploadError = "Please choose an upload format first.";
            return;
        }

        if (_uploadedWantedFile.Size > 10 * 1024 * 1024)
        {
            _uploadError = "File too large (max 10MB).";
            return;
        }

        _uploading = true;
        LoadingService.Show("Analyzing file...");
        await InvokeAsync(StateHasChanged);

        try
        {
            using var stream = _uploadedWantedFile.OpenReadStream(10 * 1024 * 1024);
            using var reader = new StreamReader(stream);
            var content = (await reader.ReadToEndAsync())?.Trim() ?? "";

            if (string.IsNullOrWhiteSpace(content))
            {
                _uploadError = "File is empty.";
                return;
            }

            var ext = Path.GetExtension(_uploadedWantedFile.Name).ToLowerInvariant();
            var looksLikeXml = ext == ".xml" || content.TrimStart().StartsWith("<");

            if ((_selectedUploadFormat == UploadFormats.RebrickableXml || _selectedUploadFormat == UploadFormats.BricklinkXml) && !looksLikeXml)
            {
                _uploadError = "Selected XML format, but file does not look like XML.";
                return;
            }

            if (_selectedUploadFormat == UploadFormats.RebrickableCsv && looksLikeXml)
            {
                _uploadError = "Selected CSV format, but file looks like XML.";
                return;
            }

            var parsed = ParseBySelectedFormat(content, _selectedUploadFormat);

            _uploadParsedItems = parsed.mapped;
            _unmappedUploadItems = parsed.unmapped;
            _invalidUploadRows = parsed.invalidRows;
            _invalidUploadColorIds = parsed.invalidColorIds;

            if (_uploadParsedItems.Count == 0)
            {
                if (_unmappedUploadItems.Count > 0 || _invalidUploadColorIds.Count > 0 || _invalidUploadRows.Count > 0)
                    _uploadError = "No usable items after validation (unmapped / invalid colors / invalid rows).";
                else
                    _uploadError = "No valid items found in file.";
            }
        }
        catch (Exception ex)
        {
            SetError(ex, "OnWantedFileSelected");
            _uploadError = $"Error processing file: {ex.Message}";
            NotificationService.Error(_error);
        }
        finally
        {
            LoadingService.Hide();
            _uploading = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private void AddUploadItemsToNewList()
    {
        foreach (var item in _uploadParsedItems)
            AddOrMergeItem(newListModel.Items, item);

        NotificationService.Success("Upload items added to list.");
        StateHasChanged();
    }

    private void ClearUpload()
    {
        _uploadedWantedFile = null;
        _uploadError = "";
        _uploadParsedItems.Clear();
        _unmappedUploadItems.Clear();
        _invalidUploadColorIds.Clear();
        _invalidUploadRows.Clear();
        StateHasChanged();
    }

    // ========= PARSER =========

    private (List<NewWantedListItemModel> mapped,
             List<(string? PartNum, int? ColorId, int Quantity)> unmapped,
             List<(string? PartNum, int? ColorId, int Qty, string Reason)> invalidRows,
             HashSet<int> invalidColorIds)
    ParseBySelectedFormat(string content, string format)
    {
        content = content.Trim();

        if (format == UploadFormats.RebrickableCsv)
            return ParseRebrickableCsv(content);

        if (format == UploadFormats.BricklinkXml)
            return ParseBricklinkXml(content);

        if (format == UploadFormats.RebrickableXml)
            return ParseRebrickableXml(content);

        return (new(), new(), new() { (null, null, 0, "Unknown upload format selected.") }, new());
    }

    private (List<NewWantedListItemModel> mapped,
             List<(string? PartNum, int? ColorId, int Quantity)> unmapped,
             List<(string? PartNum, int? ColorId, int Qty, string Reason)> invalidRows,
             HashSet<int> invalidColorIds)
    ParseRebrickableCsv(string csv)
    {
        var mapped = new List<NewWantedListItemModel>();
        var unmapped = new List<(string? PartNum, int? ColorId, int Quantity)>();
        var invalidRows = new List<(string? PartNum, int? ColorId, int Qty, string Reason)>();
        var invalidColorIds = new HashSet<int>();

        var lines = csv.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
        if (lines.Length < 2)
        {
            invalidRows.Add((null, null, 0, "CSV has no data rows."));
            return (mapped, unmapped, invalidRows, invalidColorIds);
        }

        var header = lines[0].Split(',').Select(x => x.Trim()).ToArray();
        int partIdx = Array.FindIndex(header, h => h.Equals("Part", StringComparison.OrdinalIgnoreCase));
        int colorIdx = Array.FindIndex(header, h => h.Equals("Color", StringComparison.OrdinalIgnoreCase));
        int qtyIdx = Array.FindIndex(header, h => h.Equals("Quantity", StringComparison.OrdinalIgnoreCase));

        if (partIdx < 0 || colorIdx < 0 || qtyIdx < 0)
        {
            invalidRows.Add((null, null, 0, "Invalid Rebrickable CSV header. Expected: Part,Color,Quantity."));
            return (mapped, unmapped, invalidRows, invalidColorIds);
        }

        for (int i = 1; i < lines.Length; i++)
        {
            var cols = lines[i].Split(',');
            int maxIdx = Math.Max(partIdx, Math.Max(colorIdx, qtyIdx));
            if (cols.Length <= maxIdx) continue;

            var partNum = cols[partIdx]?.Trim();
            var rbColorId = int.TryParse(cols[colorIdx]?.Trim(), out var c) ? c : (int?)null;
            var qty = int.TryParse(cols[qtyIdx]?.Trim(), out var q) ? q : 1;

            AddParsedRow_Wanted(mapped, unmapped, invalidRows, invalidColorIds,
                partNum, rbColorId, qty, colorMode: "rebrickable");
        }

        return (mapped, unmapped, invalidRows, invalidColorIds);
    }

    private (List<NewWantedListItemModel> mapped,
             List<(string? PartNum, int? ColorId, int Quantity)> unmapped,
             List<(string? PartNum, int? ColorId, int Qty, string Reason)> invalidRows,
             HashSet<int> invalidColorIds)
    ParseBricklinkXml(string xml)
    {
        // BrickLink INVENTORY XML
        // ITEMID/COLOR/MINQTY (and sometimes QTY/QUANTITY)

        var mapped = new List<NewWantedListItemModel>();
        var unmapped = new List<(string? PartNum, int? ColorId, int Quantity)>();
        var invalidRows = new List<(string? PartNum, int? ColorId, int Qty, string Reason)>();
        var invalidColorIds = new HashSet<int>();

        XDocument doc;
        try { doc = XDocument.Parse(xml); }
        catch
        {
            invalidRows.Add((null, null, 0, "Invalid XML."));
            return (mapped, unmapped, invalidRows, invalidColorIds);
        }

        var items = doc.Descendants().Where(x => x.Name.LocalName.Equals("ITEM", StringComparison.OrdinalIgnoreCase)).ToList();
        if (!items.Any())
        {
            invalidRows.Add((null, null, 0, "BrickLink XML: no <ITEM> nodes found."));
            return (mapped, unmapped, invalidRows, invalidColorIds);
        }

        foreach (var it in items)
        {
            var partNum = GetChild(it, "ITEMID")?.Trim();
            var colorStr = GetChild(it, "COLOR")?.Trim();

            var qtyStr = GetChild(it, "MINQTY") ?? GetChild(it, "QTY") ?? GetChild(it, "QUANTITY");
            var qty = int.TryParse(qtyStr, out var q) ? q : 0;

            var blColorId = int.TryParse(colorStr, out var c) ? c : (int?)null;

            if (string.IsNullOrWhiteSpace(partNum) || blColorId is null || qty <= 0)
            {
                invalidRows.Add((partNum, blColorId, qty, "Row missing ITEMID/COLOR/MINQTY (or qty<=0)."));
                continue;
            }

            AddParsedRow_Wanted(mapped, unmapped, invalidRows, invalidColorIds,
                partNum, blColorId, qty, colorMode: "bricklink");
        }

        return (mapped, unmapped, invalidRows, invalidColorIds);

        static string? GetChild(XElement parent, string name)
            => parent.Elements().FirstOrDefault(e => e.Name.LocalName.Equals(name, StringComparison.OrdinalIgnoreCase))?.Value;
    }

    private (List<NewWantedListItemModel> mapped,
             List<(string? PartNum, int? ColorId, int Quantity)> unmapped,
             List<(string? PartNum, int? ColorId, int Qty, string Reason)> invalidRows,
             HashSet<int> invalidColorIds)
    ParseRebrickableXml(string xml)
    {
        // Rebrickable XML can be:
        // A) "real" Rebrickable-like (Part/Color/Quantity)
        // B) INVENTORY/ITEM (BrickLink inventory schema) — seen in Rebrickable exports

        var mapped = new List<NewWantedListItemModel>();
        var unmapped = new List<(string? PartNum, int? ColorId, int Quantity)>();
        var invalidRows = new List<(string? PartNum, int? ColorId, int Qty, string Reason)>();
        var invalidColorIds = new HashSet<int>();

        XDocument doc;
        try { doc = XDocument.Parse(xml); }
        catch
        {
            invalidRows.Add((null, null, 0, "Invalid XML."));
            return (mapped, unmapped, invalidRows, invalidColorIds);
        }

        // -------- CASE A: Part/Color/Quantity --------
        var candidates = doc.Descendants()
            .Where(n =>
                n.Elements().Any(e => e.Name.LocalName.Equals("Part", StringComparison.OrdinalIgnoreCase) || e.Name.LocalName.Equals("PART", StringComparison.OrdinalIgnoreCase)) &&
                n.Elements().Any(e => e.Name.LocalName.Equals("Color", StringComparison.OrdinalIgnoreCase) || e.Name.LocalName.Equals("COLOR", StringComparison.OrdinalIgnoreCase)) &&
                n.Elements().Any(e => e.Name.LocalName.Equals("Quantity", StringComparison.OrdinalIgnoreCase) || e.Name.LocalName.Equals("QTY", StringComparison.OrdinalIgnoreCase)))
            .ToList();

        if (candidates.Any())
        {
            foreach (var n in candidates)
            {
                string? partNum =
                    n.Elements().FirstOrDefault(e => e.Name.LocalName.Equals("Part", StringComparison.OrdinalIgnoreCase) || e.Name.LocalName.Equals("PART", StringComparison.OrdinalIgnoreCase))?.Value?.Trim();

                string? colorStr =
                    n.Elements().FirstOrDefault(e => e.Name.LocalName.Equals("Color", StringComparison.OrdinalIgnoreCase) || e.Name.LocalName.Equals("COLOR", StringComparison.OrdinalIgnoreCase))?.Value?.Trim();

                string? qtyStr =
                    n.Elements().FirstOrDefault(e => e.Name.LocalName.Equals("Quantity", StringComparison.OrdinalIgnoreCase) || e.Name.LocalName.Equals("QTY", StringComparison.OrdinalIgnoreCase))?.Value?.Trim();

                var rbColorId = int.TryParse(colorStr, out var c) ? c : (int?)null;
                var qty = int.TryParse(qtyStr, out var q) ? q : 1;

                AddParsedRow_Wanted(mapped, unmapped, invalidRows, invalidColorIds,
                    partNum, rbColorId, qty, colorMode: "rebrickable");
            }

            return (mapped, unmapped, invalidRows, invalidColorIds);
        }

        // -------- CASE B: INVENTORY/ITEM (BrickLink schema) --------
        // Treat as BrickLink XML (color mapping via BricklinkColorMap)
        var items = doc.Descendants().Where(x => x.Name.LocalName.Equals("ITEM", StringComparison.OrdinalIgnoreCase)).ToList();
        if (!items.Any())
        {
            invalidRows.Add((null, null, 0, "Rebrickable XML: neither Part/Color/Quantity nor <ITEM> nodes found."));
            return (mapped, unmapped, invalidRows, invalidColorIds);
        }

        foreach (var it in items)
        {
            var partNum = GetChild(it, "ITEMID")?.Trim();
            var colorStr = GetChild(it, "COLOR")?.Trim();

            var qtyStr = GetChild(it, "MINQTY") ?? GetChild(it, "QTY") ?? GetChild(it, "QUANTITY");
            var qty = int.TryParse(qtyStr, out var q) ? q : 0;

            var blColorId = int.TryParse(colorStr, out var c) ? c : (int?)null;

            if (string.IsNullOrWhiteSpace(partNum) || blColorId is null || qty <= 0)
            {
                invalidRows.Add((partNum, blColorId, qty, "INVENTORY row missing ITEMID/COLOR/MINQTY (or qty<=0)."));
                continue;
            }

            // IMPORTANT: In this schema, the COLOR is a BrickLink ColorId, not a Rebrickable ColorId.
            AddParsedRow_Wanted(mapped, unmapped, invalidRows, invalidColorIds,
                partNum, blColorId, qty, colorMode: "bricklink");
        }

        return (mapped, unmapped, invalidRows, invalidColorIds);

        static string? GetChild(XElement parent, string name)
            => parent.Elements().FirstOrDefault(e => e.Name.LocalName.Equals(name, StringComparison.OrdinalIgnoreCase))?.Value;
    }

    private void AddParsedRow_Wanted(
        List<NewWantedListItemModel> mapped,
        List<(string? PartNum, int? ColorId, int Quantity)> unmapped,
        List<(string? PartNum, int? ColorId, int Qty, string Reason)> invalidRows,
        HashSet<int> invalidColorIds,
        string? partNum,
        int? colorIdFromFile,
        int qty,
        string colorMode // "rebrickable" | "bricklink"
    )
    {
        if (string.IsNullOrWhiteSpace(partNum) || !colorIdFromFile.HasValue || qty <= 0)
            return;

        var partTrim = partNum.Trim();

        if (!_brickByLegoPartNum.TryGetValue(partTrim, out var brick))
        {
            unmapped.Add((partTrim, colorIdFromFile, qty));
            return;
        }

        int? internalBrickColorId = null;

        if (colorMode == "rebrickable")
        {
            // File colorId is RebrickableColorId -> map to BrickColor.Id
            if (_rebrickableColorIdToBrickColorId.TryGetValue(colorIdFromFile.Value, out var dbColorId))
                internalBrickColorId = dbColorId;
            else
            {
                invalidColorIds.Add(colorIdFromFile.Value);
                invalidRows.Add((partTrim, colorIdFromFile, qty, "Unknown Rebrickable ColorId (not seeded)."));
                return;
            }
        }
        else // bricklink
        {
            // BrickLink 0 = Not Applicable -> ignore row
            if (BricklinkColorMap.IsNotApplicable(colorIdFromFile.Value))
            {
                invalidColorIds.Add(colorIdFromFile.Value);
                invalidRows.Add((partTrim, colorIdFromFile, qty, "BrickLink ColorId 0 = Not Applicable."));
                return;
            }

            var blName = BricklinkColorMap.GetBrickColorName(colorIdFromFile.Value);
            if (string.IsNullOrWhiteSpace(blName))
            {
                invalidColorIds.Add(colorIdFromFile.Value);
                invalidRows.Add((partTrim, colorIdFromFile, qty, "Unknown BrickLink ColorId."));
                return;
            }

            // Map by name to internal BrickColor (seeded from Rebrickable)
            if (_brickColorNameToBrickColorId.TryGetValue(blName, out var dbColorId))
                internalBrickColorId = dbColorId;
            else
            {
                invalidColorIds.Add(colorIdFromFile.Value);
                invalidRows.Add((partTrim, colorIdFromFile, qty, $"BrickLink color '{blName}' not found in BrickColors (name mismatch / missing)."));
                return;
            }
        }

        _brickById[brick.Id] = brick;

        AddOrMergeItem(mapped, new NewWantedListItemModel
        {
            MappedBrickId = brick.Id,
            BrickName = brick.Name,
            ColorId = internalBrickColorId.Value,
            Quantity = qty
        });
    }

    private static void AddOrMergeItem(List<NewWantedListItemModel> list, NewWantedListItemModel item)
    {
        var existing = list.FirstOrDefault(x => x.MappedBrickId == item.MappedBrickId && x.ColorId == item.ColorId);
        if (existing != null)
        {
            existing.Quantity += item.Quantity;
            return;
        }
        list.Add(item);
    }
}
