
@page "/add-new-set"
@using Data.Entities

@using Services
@inject Data.Services.RequestService RequestService
@inject UserService UserService
@inject Services.ItemSetService ItemSetService
@inject Services.MappedBrickService MappedBrickService

@inject Services.NotificationService NotificationService
@inject Data.Services.ImageService ImageService


<MudText Typo="Typo.h4" GutterBottom="true">Add new sets</MudText>


<MudText Typo="Typo.h6" GutterBottom="true">Your drafts</MudText>

@if (draftSets == null)
{
	<p><em>Loading drafts...</em></p>
}
else if (!draftSets.Any())
{
	<MudAlert Severity="Severity.Info">You don't have any drafts.</MudAlert>
}
else
{
	<MudTable Items="draftSets" Hover="true" Striped="true">
		<HeaderContent>
			<MudTh>Name</MudTh>
			<MudTh>Brand</MudTh>
			<MudTh>Actions</MudTh>
		</HeaderContent>
		<RowTemplate Context="set">
			<MudTd DataLabel="Name">@set.SetName (@set.SetNo)</MudTd>
			<MudTd DataLabel="Brand">@set.Brand</MudTd>
			<MudTd DataLabel="Actions">
				<MudButton Variant="Variant.Outlined" Color="Color.Primary" Size="Size.Small" Class="me-2" OnClick="@(() => EditDraftAsync(set.Id))">Edit</MudButton>
				<MudButton Variant="Variant.Outlined" Color="Color.Error" Size="Size.Small" OnClick="@(() => DeleteDraftAsync(set.Id))">Delete</MudButton>
			</MudTd>
		</RowTemplate>
	</MudTable>
}

<br />
<MudPaper Class="pa-4" >
<MudText Typo="Typo.h6" GutterBottom="true">Add a new set</MudText>

<EditForm Model="newSetModel" OnValidSubmit="HandleDraftSubmit">
	<div class="mb-2">
		<label for="setImage">Set image *</label>
		<InputFile id="setImage" OnChange="OnImageSelected" accept="image/*" />
		
		@if (!string.IsNullOrEmpty(imageError))
		{
			<div class="alert alert-danger">@imageError</div>
		}
		@if (!string.IsNullOrEmpty(imagePreviewUrl))
		{
			<div class="mt-2">
				<img src="@imagePreviewUrl" alt="set image preview" style="max-width: 300px; max-height: 300px; border: 1px solid #ccc; border-radius: 6px;" />
			</div>
		}
	</div>
	@if (!string.IsNullOrEmpty(errorMessage))
	{
		<div class="alert alert-danger">@errorMessage</div>
	}
	<DataAnnotationsValidator />
	<ValidationSummary />

	


	<MudTextField @bind-Value="newSetModel.SetName" HelperText="Set Name" Variant="Variant.Text" Adornment="Adornment.End" AdornmentIcon="@Icons.Material.Filled.AttachMoney" Style="max-width:800px;" AdornmentColor="Color.Primary"/>

	 <MudTextField @bind-Value="newSetModel.SetNo" HelperText="Set Number" Variant="Variant.Text" Adornment="Adornment.End" AdornmentIcon="@Icons.Material.Filled.AttachMoney" Style="max-width:800px;" AdornmentColor="Color.Primary"/>

	<MudSelect T="string" @bind-Value="newSetModel.Brand" Label="Select brand" Placeholder="Please select" AdornmentIcon="@Icons.Material.Filled.Fastfood" AdornmentColor="Color.Primary" Style="max-width:800px;"">
		<MudSelectItem Value="@("Lego")">Lego</MudSelectItem>
		<MudSelectItem Value="@("Cada")">Cada</MudSelectItem>
		<MudSelectItem Value="@("Unknown")">Unknown</MudSelectItem>
	</MudSelect>


	<hr />
	<h5>Bricks zum Set hinzufügen</h5>
	<div class="mb-2">
		<label for="brickSearch">Brick suchen</label>
		<InputText id="brickSearch" class="form-control" @bind-Value="brickSearchText" @oninput="OnBrickSearchInput"
			placeholder="ID oder Name..." />
		@if (brickSearchResults.Any())
		{
			<ul class="list-group mt-1">
				@foreach (var brick in brickSearchResults)
				{
					<li class="list-group-item list-group-item-action"
						style="cursor:pointer; display:flex; align-items:center; gap:8px;" @onclick="() => SelectBrick(brick)">
						<img src="@GetBrickImageUrl(brick)" alt=""
							style="width:32px;height:32px;border-radius:4px;border:1px solid #ccc;" />
						<span>@brick.LegoPartNum - @brick.LegoName</span>
					</li>
				}
			</ul>
		}
	</div>
	@if (selectedBrick != null)
	{
		<div class="mb-2">
			<label for="colorSelect">Farbe</label>
			<InputSelect id="colorSelect" class="form-control" @bind-Value="selectedColor">
				<option value="">Bitte wählen</option>
				@foreach (var color in brickColors)
				{
					<option value="@color.Name">@color.Name</option>
				}
			</InputSelect>
		</div>
		<div class="mb-2">
			<label for="quantity">Menge</label>
			<InputNumber id="quantity" class="form-control" @bind-Value="brickQuantity" min="1" />
		</div>
		<button type="button" class="btn btn-success" @onclick="AddBrickToSet">Hinzufügen</button>
	}

	<h6 class="mt-3">Bricks im Set</h6>
	@if (newSetModel.Bricks.Any())
	{
		<MudTable Items="newSetModel.Bricks" Hover="true" Striped="true">
			<HeaderContent>
				<MudTh>Brick</MudTh>
				<MudTh>Color</MudTh>
				<MudTh>Brand</MudTh>
				<MudTh>Brand ID</MudTh>
				<MudTh>Quantity</MudTh>
				<MudTh>Image</MudTh>
				<MudTh>Actions</MudTh>
			</HeaderContent>
			<RowTemplate Context="brick">
				<MudTd DataLabel="Brick">@brick.BrickName</MudTd>
				<MudTd DataLabel="Color">@brick.Color</MudTd>
				<MudTd DataLabel="Brand">@newSetModel.Brand</MudTd>
				<MudTd DataLabel="Brand ID">@brick.BrickId</MudTd>
				<MudTd DataLabel="Quantity">@brick.Quantity</MudTd>
				<MudTd DataLabel="Image">
					<img src="@GetBrickImageUrlFromId(brick.BrickId)" alt=""
						style="width:48px;height:48px;border-radius:4px;border:1px solid #ccc;" />
				</MudTd>
				<MudTd DataLabel="Actions">

					<MudButton Variant="Variant.Outlined" Color="Color.Error" Size="Size.Small"
						@onclick="() => RemoveBrick(brick)">Delete</MudButton>
				</MudTd>
			</RowTemplate>
		</MudTable>
	}


	<div class="mt-3">
		<button type="submit" class="btn btn-secondary me-2">Als Entwurf speichern</button>
		<button type="button" class="btn btn-primary" @onclick="HandlePublish">Veröffentlichen</button>
	</div>
</EditForm>
</MudPaper>

@code {
	private string? imagePreviewUrl;
	private string? imageError;
	private IBrowserFile? uploadedImageFile;

	private async Task OnImageSelected(InputFileChangeEventArgs e)
	{
		imageError = null;
		imagePreviewUrl = null;
		uploadedImageFile = null;
		var file = e.File;
		if (file == null)
		{
			imageError = "Bitte wähle ein Bild aus.";
			StateHasChanged();
			return;
		}
		if (file.Size > 3 * 1024 * 1024)
		{
			imageError = "Das Bild darf maximal 3MB groß sein.";
			StateHasChanged();
			return;
		}
		try
		{
			using var stream = file.OpenReadStream(3 * 1024 * 1024);
			var buffer = new byte[file.Size];
			await stream.ReadAsync(buffer, 0, (int)file.Size);
			var base64 = Convert.ToBase64String(buffer);
			imagePreviewUrl = $"data:{file.ContentType};base64,{base64}";
			uploadedImageFile = file;
		}
		catch (Exception ex)
		{
			imageError = $"Fehler beim Laden des Bildes: {ex.Message}";
		}
		StateHasChanged();
	}
	private bool _hasLoaded = false;
		protected override async Task OnAfterRenderAsync(bool firstRender)
		{
			if (!_hasLoaded && firstRender)
			{
				_hasLoaded = true;
				await LoadDraftsAndData();
			}
		}
	private List<Data.Entities.NewSetRequest>? draftSets;
	private List<string> brands = new();
	private NewSetModel newSetModel = new();
	private int? editingDraftId = null;
	private string? errorMessage;

	// Brick hinzufügen
	private string brickSearchText = "";
	private List<MappedBrick> brickSearchResults = new();
	private MappedBrick? selectedBrick;
	private List<BrickColor> brickColors = new();
	private string selectedColor = "";
	private int brickQuantity = 1;

	private string GetBrickImageUrlFromId(int brickId)
	{
		var brick = brickSearchResults.FirstOrDefault(b => b.Id == brickId);
		if (brick != null)
		{
			var partNum = brick.LegoPartNum;
			if (!string.IsNullOrWhiteSpace(partNum) && _brickImageCache.TryGetValue(partNum, out var url))
				return url;
		}
		return "/part_images/placeholder.png";
	}

	private async Task EditDraftAsync(int draftId)
	{
		var draft = draftSets?.FirstOrDefault(d => d.Id == draftId);
		if (draft == null) return;
		editingDraftId = draft.Id;
		var bricks = new List<NewSetBrickModel>();
		var allBricks = await MappedBrickService.GetAllMappedBricksAsync();
		foreach (var item in draft.Items)
		{
			int brickId = 0;
			string brickName = item.ItemIdOrName;
			if (int.TryParse(item.ItemIdOrName, out var id))
			{
				brickId = id;
				var brick = allBricks.FirstOrDefault(b => b.Id == id);
				if (brick != null)
				{
					brickName = brick.LegoName ?? brick.LegoPartNum ?? item.ItemIdOrName;
				}
			}
			bricks.Add(new NewSetBrickModel
			{
				BrickId = brickId,
				BrickName = brickName,
				Color = item.Color,
				Quantity = item.Quantity
			});
		}
		newSetModel = new NewSetModel
		{
			SetName = draft.SetName,
			SetNo = draft.SetNo,
			Brand = draft.Brand,
			Bricks = bricks
		};
		uploadedImageFile = null;
		StateHasChanged();
	}

		private async Task LoadDraftsAndData()
	{
		var user = await UserService.GetCurrentUserAsync();
		if (user == null)
		{
			draftSets = new List<Data.Entities.NewSetRequest>();
			return;
		}
		var allSets = await RequestService.GetNewSetRequestsByUserAsync(user.Uuid);
		draftSets = allSets.Where(s => s.Status == Data.Entities.NewSetRequestStatus.Draft).ToList();
		brands = await GetAllBrandsAsync();
		brickColors = await MappedBrickService.GetAllColorsAsync();
		StateHasChanged();
	}

	private void RemoveBrick(NewSetBrickModel brick)
	{
		newSetModel.Bricks.Remove(brick);
		StateHasChanged();
	}


	private Dictionary<string, string> _brickImageCache = new();

	private string GetBrickImageUrl(MappedBrick brick)
	{
		var partNum = brick.LegoPartNum;
		if (!string.IsNullOrWhiteSpace(partNum) && _brickImageCache.TryGetValue(partNum, out var url))
			return url;
		return "/part_images/placeholder.png";
	}

	private async void OnBrickSearchInput(ChangeEventArgs e)
	{
		brickSearchText = e.Value?.ToString() ?? "";
		if (brickSearchText.Length < 2)
		{
			brickSearchResults.Clear();
			StateHasChanged();
			return;
		}
		var allBricks = await MappedBrickService.GetAllMappedBricksAsync();
		brickSearchResults = allBricks.Where(b => (b.LegoPartNum?.Contains(brickSearchText, StringComparison.OrdinalIgnoreCase)
		?? false) || (b.LegoName?.Contains(brickSearchText, StringComparison.OrdinalIgnoreCase) ?? false)).Take(10).ToList();
		   foreach (var brick in brickSearchResults)
		   {
			   var partNum = brick.LegoPartNum;
			   if (!string.IsNullOrWhiteSpace(partNum) && !_brickImageCache.ContainsKey(partNum))
			   {
				   // Use ImageService to get the image path
				   var url = ImageService.GetMappedBrickImagePath(brick);
				   _brickImageCache[partNum] = string.IsNullOrWhiteSpace(url) ? "/part_images/placeholder.png" : url;
			   }
		   }
		   StateHasChanged();
	}

	private void SelectBrick(MappedBrick brick)
	{
		selectedBrick = brick;
		selectedColor = "";
		brickQuantity = 1;
		brickSearchResults.Clear();
		brickSearchText = brick.LegoPartNum ?? brick.LegoName ?? "";
		StateHasChanged();
	}

	private void AddBrickToSet()
	{
		if (selectedBrick == null || string.IsNullOrEmpty(selectedColor) || brickQuantity < 1)
			return;
		newSetModel.Bricks.Add(new NewSetBrickModel
		{
			BrickId = selectedBrick.Id,
			BrickName = selectedBrick.LegoName ?? selectedBrick.LegoPartNum ?? "",
			Color = selectedColor,
			Quantity = brickQuantity
		});
		selectedBrick = null;
		selectedColor = "";
		brickQuantity = 1;
		brickSearchText = "";
		StateHasChanged();
	}

	private async Task<List<string>> GetAllBrandsAsync()
	{
		// Hole alle Brands aus ItemSets
		var itemSets = await ItemSetService.GetPaginatedItemSetsAsync(1, 1000);
		return itemSets.Items.Select(s => s.Brand).Distinct().OrderBy(b => b).ToList();
	}

	private async Task HandleDraftSubmit()
	{
		errorMessage = null;
		var user = await UserService.GetCurrentUserAsync();
		if (user == null){
			NotificationService.Error("Kein User gefunden. Bitte melde dich an.");
			return;
		}
		if (uploadedImageFile == null)
		{
			errorMessage = "Bitte lade ein Bild für das Set hoch.";
			StateHasChanged();
			return;
		}
		// Prüfe auf Duplikat
		var itemSets = await ItemSetService.GetPaginatedItemSetsAsync(1, 1000);
		var exists = itemSets.Items.Any(s => s.Brand == newSetModel.Brand && (s.Name == newSetModel.SetName || s.LegoSetNum == newSetModel.SetNo));
		if (exists)
		{
			errorMessage = "Es existiert bereits ein Set mit dieser Brand und Name oder Set ID.";
			StateHasChanged();
			return;
		}
		string? imagePath = null;
		try
		{
			imagePath = await ImageService.SaveSetImageAsync(uploadedImageFile, newSetModel.Brand, newSetModel.SetNo);
		}
		catch (Exception ex)
		{
			errorMessage = $"Fehler beim Speichern des Bildes: {ex.Message}";
			StateHasChanged();
			return;
		}
		var items = newSetModel.Bricks.Select(b => new Data.Entities.NewSetRequestItem
		{
			ItemIdOrName = b.BrickId != 0 ? b.BrickId.ToString() : b.BrickName,
			Quantity = b.Quantity,
			Color = b.Color
		}).ToList();
		if (editingDraftId.HasValue)
		{
			// Update existing draft in-place
			await RequestService.UpdateNewSetRequestAsync(editingDraftId.Value, newSetModel.Brand, newSetModel.SetNo, newSetModel.SetName, imagePath, items, Data.Entities.NewSetRequestStatus.Draft);
		}
		else
		{
			await RequestService.CreateNewSetRequestAsync(newSetModel.Brand, newSetModel.SetNo, newSetModel.SetName, imagePath,
				user.Uuid, items, Data.Entities.NewSetRequestStatus.Draft);
		}
		await LoadDraftsAndData();
		newSetModel = new();
		editingDraftId = null;
		uploadedImageFile = null;
		imagePreviewUrl = null;
		NotificationService.Success("Set erfolgreich als Entwurf gespeichert.");
		StateHasChanged();
	}

	private async Task HandlePublish()
	{
		errorMessage = null;
		var user = await UserService.GetCurrentUserAsync();
		if (user == null) return;

		// Prüfe auf Duplikat
		var itemSets = await ItemSetService.GetPaginatedItemSetsAsync(1, 1000);
		var exists = itemSets.Items.Any(s => s.Brand == newSetModel.Brand && (s.Name == newSetModel.SetName || s.LegoSetNum == newSetModel.SetNo));
		if (exists)
		{
			errorMessage = "Es existiert bereits ein Set mit dieser Brand und Name oder Set ID.";
			StateHasChanged();
			return;
		}

		string? imagePath = null;
		if (uploadedImageFile != null)
		{
			try
			{
				imagePath = await ImageService.SaveSetImageAsync(uploadedImageFile, newSetModel.Brand, newSetModel.SetNo);
			}
			catch (Exception ex)
			{
				errorMessage = $"Fehler beim Speichern des Bildes: {ex.Message}";
				StateHasChanged();
				return;
			}
		}
		else if (editingDraftId.HasValue)
		{
			// Wenn kein neues Bild hochgeladen wurde, aber ein Entwurfsbild existiert, verwende dieses
			var draft = draftSets?.FirstOrDefault(d => d.Id == editingDraftId.Value);
			@* if (draft != null && !string.IsNullOrWhiteSpace(draft.ImagePath))
			{
				imagePath = draft.ImagePath;
			}
			else
			{
				errorMessage = "Bitte lade ein Bild für das Set hoch.";
				StateHasChanged();
				return;
			} *@
		}
		else
		{
			errorMessage = "Bitte lade ein Bild für das Set hoch.";
			StateHasChanged();
			return;
		}

		// Veröffentlichen: Status Pending
		var items = newSetModel.Bricks.Select(b => new Data.Entities.NewSetRequestItem
		{
			ItemIdOrName = b.BrickId != 0 ? b.BrickId.ToString() : b.BrickName,
			Quantity = b.Quantity,
			Color = b.Color
		}).ToList();
		if (editingDraftId.HasValue)
		{
			// Update draft to Pending (publish)
			var draft = draftSets?.FirstOrDefault(d => d.Id == editingDraftId.Value);
			if (draft != null)
			{
				await RequestService.DeleteNewSetRequestAsync(draft.Id); // Remove old draft
			}
		}
		await RequestService.CreateNewSetRequestAsync(newSetModel.Brand, newSetModel.SetNo, newSetModel.SetName, imagePath,
			user.Uuid, items, Data.Entities.NewSetRequestStatus.Pending);
		await LoadDraftsAndData();
		newSetModel = new();
		editingDraftId = null;
		uploadedImageFile = null;
		imagePreviewUrl = null;
		NotificationService.Success("Set erfolgreich zur Überprüfung eingereicht.");
		StateHasChanged();
	}

	private async Task DeleteDraftAsync(int id)
	{
		await RequestService.DeleteNewSetRequestAsync(id);
		var user = await UserService.GetCurrentUserAsync();
		if (user != null)
		{
				await LoadDraftsAndData();
			StateHasChanged();
		}
	}

	public class NewSetModel
	{
		public string SetName { get; set; } = string.Empty;
		public string SetNo { get; set; } = string.Empty;
		public string Brand { get; set; } = string.Empty;
		public List<NewSetBrickModel> Bricks { get; set; } = new();
	}

	public class NewSetBrickModel
	{
		public int BrickId { get; set; }
		public string BrickName { get; set; } = string.Empty;
		public string Color { get; set; } = string.Empty;
		public int Quantity { get; set; }
	}
}