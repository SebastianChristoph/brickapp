@page "/mymocks"
@using System.Xml.Linq
@using Data.Entities
@using Microsoft.AspNetCore.Components.Forms
@using Services
@inject NavigationManager Nav
@inject IServiceProvider ServiceProvider
@inject UserService UserService

<h3>My Mocks</h3>


<MudPaper Class="pa-4 mb-4">
        <MudButton Variant="Variant.Outlined" Color="Color.Error" OnClick="DeleteAllMocks" Class="ml-2">Alle Mocks löschen</MudButton>
        <MudText Typo="Typo.h6">Neues Mock hochladen</MudText>
        <MudSelect @bind-Value="selectedFormat" Label="Dateiformat" Style="width:200px;">
            <MudSelectItem Value="@("bricklink")">bricklink List (XML)</MudSelectItem>
            <!-- Weitere Formate später -->
        </MudSelect>
        <MudTextField @bind-Value="newMockName" Label="Mock-Name" Style="width:200px;margin-top:8px;" />
        <InputFile OnChange="OnFileSelected" accept=".xml" />
        <MudText Color="Color.Error">@uploadError</MudText>
</MudPaper>

@if (unmappedItems.Count > 0)
    {
        <MudPaper Class="pa-2 mb-2" Style="background:#fffbe6;border:1px solid #ffe082;">
            <MudText Color="Color.Warning" Typo="Typo.subtitle2">
                Für folgende Items wurde kein MappedBrick gefunden:
            </MudText>
            <MudList T="string">
                @foreach (var item in unmappedItems)
                {
                    <MudListItem T="string">
                        <MudText>ITEMID: <b>@item.PartNum</b>, COLOR: <b>@item.ColorId</b>, QTY: <b>@item.Quantity</b></MudText>
                    </MudListItem>
                }
            </MudList>
        </MudPaper>
    }

<MudPaper Class="pa-4">
    <MudText Typo="Typo.h6">Deine Mocks</MudText>
    <MudList T="string">
        @if (userMocks == null)
        {
            <MudText>Wird geladen...</MudText>
        }
        else if (!userMocks.Any())
        {
            <MudText>Keine Mocks gefunden.</MudText>
        }
        else
        {
            @foreach (var mock in userMocks)
            {
                <MudListItem T="string" Style="display:flex;align-items:center;justify-content:space-between;cursor:pointer">
                    <span style="flex:1" @onclick="@(() => Nav.NavigateTo($"/mockdetail/{mock.Id}"))">
                        <MudText>@mock.Name</MudText>
                    </span>
                    <MudButton Variant="Variant.Outlined" Color="Color.Error" Size="Size.Small" Style="margin-left:8px" OnClick="@(() => DeleteMock(mock.Id))">Löschen</MudButton>
                </MudListItem>
            }
        }
    </MudList>
</MudPaper>

@code {
    private List<Mock>? userMocks;
    private string uploadError = string.Empty;
    private List<(string? PartNum, int? ColorId, int Quantity)> unmappedItems = new();
    private string selectedFormat = "bricklink";
    private string newMockName = string.Empty;

    private async Task DeleteMock(int mockId)
    {
        var userUuid = await UserService.GetTokenAsync();
        if (string.IsNullOrEmpty(userUuid))
            return;
        using var scope = ServiceProvider.CreateScope();
        var db = scope.ServiceProvider.GetRequiredService<Data.AppDbContext>();
        var mock = db.Mocks.FirstOrDefault(m => m.Id == mockId && m.UserUuid == userUuid);
        if (mock != null)
        {
            db.Mocks.Remove(mock);
            db.SaveChanges();
        }
        await LoadMocks();
    }

    private async Task DeleteAllMocks()
    {
        var userUuid = await UserService.GetTokenAsync();
        if (string.IsNullOrEmpty(userUuid))
            return;
        using var scope = ServiceProvider.CreateScope();
        var db = scope.ServiceProvider.GetRequiredService<Data.AppDbContext>();
        var mocks = db.Mocks.Where(m => m.UserUuid == userUuid).ToList();
        if (mocks.Any())
        {
            db.Mocks.RemoveRange(mocks);
            db.SaveChanges();
        }
        await LoadMocks();
    }


    private bool _loaded = false;
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_loaded)
        {
            _loaded = true;
            await LoadMocks();
            StateHasChanged();
        }
    }

    private async Task LoadMocks()
    {
        using var scope = ServiceProvider.CreateScope();
        var db = scope.ServiceProvider.GetRequiredService<Data.AppDbContext>();
        var userUuid = await UserService.GetTokenAsync();
        
        if (string.IsNullOrEmpty(userUuid))
        {
            userMocks = new();
            return;
        }
        userMocks = db.Mocks.Where(m => m.UserUuid == userUuid).ToList();
    }

    private async Task OnFileSelected(InputFileChangeEventArgs e)
    {
        uploadError = string.Empty;
        var file = e.File;
        if (file == null)
            return;
        try
        {
            unmappedItems.Clear();
            using var stream = file.OpenReadStream();
            using var reader = new StreamReader(stream);
            var xmlString = await reader.ReadToEndAsync();
            var doc = XDocument.Parse(xmlString);
            var items = new List<MockItem>();
            using var scope = ServiceProvider.CreateScope();
            var db = scope.ServiceProvider.GetRequiredService<Data.AppDbContext>();
            foreach (var x in doc.Descendants("ITEM"))
            {
                var partNum = x.Element("ITEMID")?.Value;
                var colorId = int.TryParse(x.Element("COLOR")?.Value, out var cid) ? cid : (int?)null;
                var qty = int.TryParse(x.Element("MINQTY")?.Value, out var q) ? q : 1;
                int? mappedBrickId = null;
                if (!string.IsNullOrEmpty(partNum))
                {
                    var mapped = db.MappedBricks.FirstOrDefault(b => b.LegoPartNum == partNum);
                    if (mapped != null)
                        mappedBrickId = mapped.Id;
                }
                if (mappedBrickId == null)
                {
                    unmappedItems.Add((partNum, colorId, qty));
                }
                items.Add(new MockItem
                {
                    ExternalPartNum = partNum,
                    Quantity = qty,
                    BrickColorId = colorId,
                    MappedBrickId = mappedBrickId
                });
            }
            var name = string.IsNullOrWhiteSpace(newMockName) ? file.Name : newMockName.Trim();
            var userUuid = await UserService.GetTokenAsync();
            if (string.IsNullOrEmpty(userUuid))
            {
                uploadError = "Nicht eingeloggt.";
                return;
            }
            var mock = new Mock
            {
                Name = name,
                UserUuid = userUuid,
                MockType = selectedFormat,
                Items = items
            };
            db.Mocks.Add(mock);
            db.SaveChanges();
            newMockName = string.Empty;
            await LoadMocks();
        }
        catch (Exception ex)
        {
            uploadError = $"Fehler beim Hochladen: {ex.Message}";
        }
    
    }
}
