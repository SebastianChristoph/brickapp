@page "/mymocs"
@using System.Xml.Linq
@using Microsoft.EntityFrameworkCore
@using Data.Entities
@using Microsoft.AspNetCore.Components.Forms
@using Services
@inject NavigationManager Nav
@inject IServiceProvider ServiceProvider
@inject Data.Services.ImageService ImageService
@inject UserService UserService
@using IBrowserFile = Microsoft.AspNetCore.Components.Forms.IBrowserFile


 <MudText Typo="Typo.h4" GutterBottom="true">My MOCs</MudText>

 <MudStack Row="true" Justify="Justify.FlexEnd"Spacing="2" Style="margin-bottom: 16px;">
    <MudButton StartIcon="@Icons.Material.Filled.Delete" Variant="Variant.Outlined" Color="Color.Error" OnClick="DeleteAllMocks" Class="ml-2">Delete all MOCs</MudButton>

 </MudStack>

<MudPaper Class="pa-4 mb-4">
       
        <MudText Typo="Typo.h6">Upload a new MOC</MudText>
        <MudSelect @bind-Value="selectedFormat" Label="Item List Source" Style="width:200px;">
            <MudSelectItem Value="@("rebrickable")">Rebrickable List (CSV)</MudSelectItem>
            <MudSelectItem Value="@("bricklink")">Bricklink List (XML)</MudSelectItem>
        </MudSelect>
        <MudTextField @bind-Value="newMockName" Label="MOC name" Style="width:200px;margin-top:8px;" />

        <MudTextField @bind-Value="newMockComment" Label="Comment" HelperText="optional (e.g., This is my custom MOC)" Style="width:200px;margin-top:8px;" Lines="3" TextFieldStyle="MudBlazor.TextFieldStyle.Multiline" />

        <MudTextField @bind-Value="newMockWebSource" Label="Web Source"  HelperText="optional (e.g., https://example.com)" Class="width:200px;  margin-top:8px;" />

        <div style="margin-top:8px;">
            <label>Upload MOC image (max 3MB)</label>
            <InputFile OnChange="OnImageSelected" accept="image/*" />
        </div>
        @if (!string.IsNullOrEmpty(imagePreviewUrl))
        {
            <div style="margin-top:8px;">
                <img src="@imagePreviewUrl" alt="Mock Bild Vorschau" style="max-width:200px;max-height:200px;border:1px solid #ccc;padding:2px;" />
            </div>
        }
        <br>
        <MudText variant="body1">Upload Item List File:</MudText>
        <InputFile OnChange="OnFileSelected" accept="@(selectedFormat == "bricklink" ? ".xml" : ".csv")" />
        <br>
        <br>

        @if (unmappedItems.Count > 0)
    {
        <MudAlert Severity="Severity.Warning" Class="mb-4">
            Some items could not be mapped to existing MappedBricks. Please review the list below and consider adding mappings for these items first. Missing mapped items will be ignored when creating the MOC.</MudAlert>
        <MudExpansionPanels>
             <MudExpansionPanel Text="Click here to see unmapped items" MaxHeight="450" Expanded="false">
        <MudPaper Class="pa-2 mb-2" Style="background:#fffbe6;border:1px solid #ffe082;">
            <MudText Color="Color.Warning" Typo="Typo.subtitle2">
                For the following items no MappedBrick was found:
            </MudText>
            <MudList T="string">
                @foreach (var item in unmappedItems)
                {
                    <MudListItem T="string">
                        <MudText>Part Number: <b>@item.PartNum</b>, Color: <b>@item.ColorId</b>, Quantity: <b>@item.Quantity</b></MudText>
                    </MudListItem>
                }
            </MudList>
        </MudPaper>
        </MudExpansionPanel>
        </MudExpansionPanels>
    }else if (unmappedItems.Count == 0 && uploadedItems.Count > 0){
         <MudAlert Severity="Severity.Success" Class="mb-4">
            All items were successfully mapped to existing MappedBricks.</MudAlert>
    }
        
        <MudButton StartIcon="@Icons.Material.Filled.Add" Variant="Variant.Filled" Color="Color.Primary" OnClick="CreateMockFromUpload" Disabled="@(!fileReadyForUpload)" Class="ml-2 mt-2">
            @(unmappedItems.Count > 0 ? "Create new MOC anyway" : "Create new MOC")
        </MudButton>

        <MudText Color="Color.Error">@uploadError</MudText>
</MudPaper>



<MudPaper Class="pa-4">
    <MudText Typo="Typo.h6">Your MOCs</MudText>
    <MudList T="string">
        @if (userMocks == null)
        {
            <MudText>Loading...</MudText>
        }
        else if (!userMocks.Any())
        {
            <MudAlert Severity="Severity.Info">No MOCs found.</MudAlert>
        }
        else
        {
            using var scope = ServiceProvider.CreateScope();
            var db = scope.ServiceProvider.GetRequiredService<Data.AppDbContext>();
            var userUuid = UserService.GetTokenAsync().Result;
            var inventory = db.InventoryItems.Where(i => i.AppUser.Uuid == userUuid).ToList();

            @foreach (var mock in userMocks)
            {
                var totalParts = mock.Items?.Sum(i => i.Quantity) ?? 0;
                // Besitzte Teile berechnen
                int ownedParts = 0;
                if (mock.Items != null)
                {
                    foreach (var item in mock.Items)
                    {
                        if (item.MappedBrickId != null && item.BrickColorId != null)
                        {
                            var inv = inventory.Where(invItem => invItem.MappedBrickId == item.MappedBrickId && invItem.BrickColorId == item.BrickColorId).Sum(invItem => invItem.Quantity);
                            ownedParts += Math.Min(inv, item.Quantity);
                        }
                    }
                }
                var percent = (totalParts > 0) ? (int)Math.Floor(100.0 * ownedParts / totalParts) : 0;

                <MudListItem T="string" Style="display:flex;align-items:center;justify-content:space-between;cursor:pointer">
                    <div style="display:flex;align-items:center;flex:1;gap:12px;">
                        <img src="@ImageService.GetMockImagePath(mock)" alt="Mock Bild" style="width:56px;height:56px;object-fit:contain;border:1px solid #ccc;background:#fff;padding:2px;border-radius:6px;" />
                        <span style="flex:1" @onclick="@(() => Nav.NavigateTo($"/mockdetail/{mock.Id}"))">
                            <MudText><b>@mock.Name</b> <span style="color:#888;font-size:0.95em">(@mock.MockType)</span></MudText>
                            <MudText Typo="Typo.caption">Items: @totalParts</MudText>
                            <MudText Typo="Typo.caption">Owned: @ownedParts / @totalParts (@percent%)</MudText>
                            <MudProgressLinear Value="@percent" Color="@(percent == 100 ? Color.Success : Color.Primary)" Style="max-width:120px;height:8px;margin-top:2px;" />
                            @if (!string.IsNullOrWhiteSpace(mock.WebSource))
                            {
                                <MudText Typo="Typo.caption">
                                    <a href="@mock.WebSource" target="_blank" rel="noopener noreferrer" style="color:#1976d2;text-decoration:underline;">Web-Source</a>
                                </MudText>
                            }
                            @if (!string.IsNullOrWhiteSpace(mock.Comment))
                            {
                                <MudText Typo="Typo.caption" Style="color:#666;"><br />Comment: @mock.Comment</MudText>
                            }
                        </span>
                    </div>
                    <MudButton Variant="Variant.Outlined" Color="Color.Error" Size="Size.Small" Style="margin-left:8px" OnClick="@(() => DeleteMock(mock.Id))">Delete </MudButton>
                </MudListItem>
            }
        }
    </MudList>
</MudPaper>

@code {
    private List<Mock>? userMocks;
    private string uploadError = string.Empty;
    private List<(string? PartNum, int? ColorId, int Quantity)> unmappedItems = new();
    
    private string selectedFormat = "rebrickable";
    private string newMockName = string.Empty;
    private string newMockComment = string.Empty;
    private string newMockWebSource = string.Empty;
    private List<MockItem> uploadedItems = new();
    private IBrowserFile? uploadedFile = null;
    private bool fileReadyForUpload = false;
    private IBrowserFile? uploadedImage = null;
    private string imagePreviewUrl = string.Empty;
    private async Task OnImageSelected(InputFileChangeEventArgs e)
    {
        uploadError = string.Empty;
        imagePreviewUrl = string.Empty;
        uploadedImage = null;
        var file = e.File;
        if (file == null)
            return;
        if (file.Size > 3 * 1024 * 1024)
        {
            uploadError = "Das Bild darf maximal 3MB groß sein.";
            return;
        }
        uploadedImage = file;
        try
        {
            // Read as base64 for preview
            using var stream = file.OpenReadStream(3 * 1024 * 1024);
            using var ms = new MemoryStream();
            await stream.CopyToAsync(ms);
            var bytes = ms.ToArray();
            var base64 = Convert.ToBase64String(bytes);
            var ext = Path.GetExtension(file.Name)?.ToLowerInvariant().TrimStart('.') ?? "png";
            var mime = file.ContentType;
            if (string.IsNullOrEmpty(mime))
            {
                // fallback
                mime = ext == "jpg" || ext == "jpeg" ? "image/jpeg" : ext == "png" ? "image/png" : "image/*";
            }
            imagePreviewUrl = $"data:{mime};base64,{base64}";
        }
        catch (Exception ex)
        {
            uploadError = $"Fehler beim Laden des Bildes: {ex.Message}";
        }
    }

    private async Task DeleteMock(int mockId)
    {
        var userUuid = await UserService.GetTokenAsync();
        if (string.IsNullOrEmpty(userUuid))
            return;
        using var scope = ServiceProvider.CreateScope();
        var db = scope.ServiceProvider.GetRequiredService<Data.AppDbContext>();
        var mock = db.Mocks.FirstOrDefault(m => m.Id == mockId && m.UserUuid == userUuid);
        if (mock != null)
        {
            // Bild löschen
            ImageService.DeleteMockImage(mock);
            db.Mocks.Remove(mock);
            db.SaveChanges();
        }
        await LoadMocks();
    }

    private async Task DeleteAllMocks()
    {
        var userUuid = await UserService.GetTokenAsync();
        if (string.IsNullOrEmpty(userUuid))
            return;
        using var scope = ServiceProvider.CreateScope();
        var db = scope.ServiceProvider.GetRequiredService<Data.AppDbContext>();
        var mocks = db.Mocks.Where(m => m.UserUuid == userUuid).ToList();
        if (mocks.Any())
        {
            foreach (var mock in mocks)
            {
                ImageService.DeleteMockImage(mock);
            }
            db.Mocks.RemoveRange(mocks);
            db.SaveChanges();
        }
        await LoadMocks();
    }


    private bool _loaded = false;
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_loaded)
        {
            _loaded = true;
            await LoadMocks();
            StateHasChanged();
        }
    }

    private async Task LoadMocks()
    {
        using var scope = ServiceProvider.CreateScope();
        var db = scope.ServiceProvider.GetRequiredService<Data.AppDbContext>();
        var userUuid = await UserService.GetTokenAsync();
        
        if (string.IsNullOrEmpty(userUuid))
        {
            userMocks = new();
            return;
        }
        userMocks = db.Mocks
            .Where(m => m.UserUuid == userUuid)
            .Include(m => m.Items)
            .ToList();
    }

    private async Task OnFileSelected(InputFileChangeEventArgs e)
    {
        uploadError = string.Empty;
        uploadedFile = e.File;
        fileReadyForUpload = false;
        uploadedItems.Clear();
        unmappedItems.Clear();
        if (uploadedFile == null)
            return;

        // Dateiendung prüfen
        if (selectedFormat == "bricklink" && !uploadedFile.Name.EndsWith(".xml", StringComparison.OrdinalIgnoreCase))
        {
            uploadError = "Please select an XML file for Bricklink.";
            return;
        }
        if (selectedFormat == "rebrickable" && !uploadedFile.Name.EndsWith(".csv", StringComparison.OrdinalIgnoreCase))
        {
            uploadError = "Please select a CSV file for Rebrickable.";
            return;
        }

        try
        {
            using var stream = uploadedFile.OpenReadStream();
            using var reader = new StreamReader(stream);
            var items = new List<MockItem>();
            using var scope = ServiceProvider.CreateScope();
            var db = scope.ServiceProvider.GetRequiredService<Data.AppDbContext>();

            if (selectedFormat == "bricklink")
            {
                var xmlString = await reader.ReadToEndAsync();
                XDocument doc;
                try
                {
                    doc = XDocument.Parse(xmlString);
                }
                catch
                {
                    uploadError = "Die XML-Datei ist ungültig.";
                    return;
                }
                if (!doc.Descendants("ITEM").Any())
                {
                    uploadError = "Die Bricklink-XML enthält keine Items.";
                    return;
                }
                foreach (var x in doc.Descendants("ITEM"))
                {
                    var partNum = x.Element("ITEMID")?.Value;
                    var colorId = int.TryParse(x.Element("COLOR")?.Value, out var cid) ? cid : (int?)null;
                    var qty = int.TryParse(x.Element("MINQTY")?.Value, out var q) ? q : 1;
                    int? mappedBrickId = null;
                    if (!string.IsNullOrEmpty(partNum))
                    {
                        var mapped = db.MappedBricks.FirstOrDefault(b => b.LegoPartNum == partNum);
                        if (mapped != null)
                            mappedBrickId = mapped.Id;
                    }
                    if (mappedBrickId == null)
                    {
                        unmappedItems.Add((partNum, colorId, qty));
                    }
                    items.Add(new MockItem
                    {
                        ExternalPartNum = partNum,
                        Quantity = qty,
                        BrickColorId = colorId,
                        MappedBrickId = mappedBrickId
                    });
                }
            }
            else if (selectedFormat == "rebrickable")
            {
                var csv = await reader.ReadToEndAsync();
                var lines = csv.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
                if (lines.Length < 2)
                {
                    uploadError = "Die CSV-Datei enthält keine Daten.";
                    return;
                }
                var header = lines[0].Split(',');
                var expectedHeader = new[] { "Part", "Color", "Quantity", "Is Spare" };
                if (header.Length != expectedHeader.Length || !expectedHeader.SequenceEqual(header))
                {
                    uploadError = $"Die CSV-Datei muss exakt die Spalten {string.Join(", ", expectedHeader)} enthalten.";
                    return;
                }
                int partIdx = Array.IndexOf(header, "Part");
                int colorIdx = Array.IndexOf(header, "Color");
                int qtyIdx = Array.IndexOf(header, "Quantity");
                for (int i = 1; i < lines.Length; i++)
                {
                    var cols = lines[i].Split(',');
                    if (cols.Length != expectedHeader.Length)
                    {
                        uploadError = $"Zeile {i + 1} hat nicht die korrekte Anzahl an Spalten.";
                        return;
                    }
                    var partNum = cols[partIdx];
                    var colorId = int.TryParse(cols[colorIdx], out var cid) ? cid : (int?)null;
                    var qty = int.TryParse(cols[qtyIdx], out var q) ? q : 1;
                    int? mappedBrickId = null;
                    if (!string.IsNullOrEmpty(partNum))
                    {
                        var mapped = db.MappedBricks.FirstOrDefault(b => b.LegoPartNum == partNum);
                        if (mapped != null)
                            mappedBrickId = mapped.Id;
                    }
                    if (mappedBrickId == null)
                    {
                        unmappedItems.Add((partNum, colorId, qty));
                    }
                    items.Add(new MockItem
                    {
                        ExternalPartNum = partNum,
                        Quantity = qty,
                        BrickColorId = colorId,
                        MappedBrickId = mappedBrickId
                    });
                }
            }

            uploadedItems = items;
            fileReadyForUpload = true;
        }
        catch (Exception ex)
        {
            uploadError = $"Fehler beim Verarbeiten der Datei: {ex.Message}";
            fileReadyForUpload = false;
        }
    }

    private async Task CreateMockFromUpload()
    {
        uploadError = string.Empty;
        // Pflichtfelder prüfen
        if (string.IsNullOrWhiteSpace(newMockName))
        {
            uploadError = "Please provide a name for the mock.";
            return;
        }
        if (uploadedFile == null || uploadedItems == null || uploadedItems.Count == 0)
        {
            uploadError = "Please upload a valid mock list.";
            return;
        }
        try
        {
            using var scope = ServiceProvider.CreateScope();
            var db = scope.ServiceProvider.GetRequiredService<Data.AppDbContext>();
            var name = string.IsNullOrWhiteSpace(newMockName) ? uploadedFile.Name : newMockName.Trim();
            var userUuid = await UserService.GetTokenAsync();
            if (string.IsNullOrEmpty(userUuid))
            {
                uploadError = "Nicht eingeloggt.";
                return;
            }
            // Nur Items mit gültigen MappedBrickId und BrickColorId, die auch wirklich existieren, speichern
            var validItems = new List<MockItem>();
            foreach (var i in uploadedItems)
            {
                if (i.MappedBrickId == null || i.BrickColorId == null)
                    continue;
                var mappedExists = db.MappedBricks.Any(b => b.Id == i.MappedBrickId);
                var colorExists = db.BrickColors.Any(c => c.Id == i.BrickColorId);
                if (mappedExists && colorExists)
                    validItems.Add(i);
            }

            var mock = new Mock
            {
                Name = name,
                UserUuid = userUuid,
                MockType = selectedFormat,
                Items = validItems,
                Comment = string.IsNullOrWhiteSpace(newMockComment) ? null : newMockComment.Trim(),
                WebSource = string.IsNullOrWhiteSpace(newMockWebSource) ? null : newMockWebSource.Trim(),
            };
            db.Mocks.Add(mock);
            db.SaveChanges();

            // Bild speichern, falls vorhanden, über ImageService
            if (uploadedImage != null)
            {
                try
                {
                    var imagePath = await ImageService.SaveMockImageAsync(uploadedImage, userUuid, mock.Id);
                    if (!string.IsNullOrEmpty(imagePath))
                    {
                        db.SaveChanges();
                    }
                }
                catch (Exception ex)
                {
                    uploadError = $"Bild konnte nicht gespeichert werden: {ex.Message}";
                }
            }

            newMockName = string.Empty;
            newMockComment = string.Empty;
            newMockWebSource = string.Empty;
            uploadedFile = null;
            uploadedItems.Clear();
            fileReadyForUpload = false;
            unmappedItems.Clear();
            uploadedImage = null;
            imagePreviewUrl = string.Empty;
            await LoadMocks();
        }
        catch (Exception ex)
        {
            uploadError = $"Fehler beim Speichern: {ex.Message}";
        }
    }
}
