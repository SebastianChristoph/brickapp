@page "/mymocs"
@using System.Xml.Linq
@using Microsoft.EntityFrameworkCore
@using Data.Entities
@using Microsoft.AspNetCore.Components.Forms
@using Services
@using MudBlazor
@inject NavigationManager Nav
@inject IServiceProvider ServiceProvider
@inject Data.Services.ImageService ImageService
@inject UserService UserService
@inject Services.LoadingService LoadingService
@inject Services.NotificationService NotificationService
@using IBrowserFile = Microsoft.AspNetCore.Components.Forms.IBrowserFile

<MudText Typo="Typo.h4" GutterBottom="true">My MOCs</MudText>

@if (!string.IsNullOrWhiteSpace(_error))
{
    <MudAlert Severity="Severity.Error" Variant="Variant.Filled" Class="mb-4">
        @_error
        @if (!string.IsNullOrWhiteSpace(_errorDetails))
        {
            <MudDivider Class="my-2" />
            <MudText Typo="Typo.caption" Style="white-space:pre-wrap;">@_errorDetails</MudText>
        }
    </MudAlert>
}


<MudPaper Class="pa-4 mb-4">
    <MudText Typo="Typo.h6">Upload a new MOC</MudText>

    <MudSelect T="string" @bind-Value="selectedFormat"
               Label="Item List Source"
               Disabled="_loading"
               Style="width:260px;">
        <MudSelectItem Value="@Formats.RebrickableCsv">Rebrickable CSV</MudSelectItem>
        <MudSelectItem Value="@Formats.RebrickableXml">Rebrickable XML</MudSelectItem>
        <MudSelectItem Value="@Formats.BricklinkXml">BrickLink XML</MudSelectItem>
        <MudSelectItem Value="@Formats.CsvAuto">CSV (auto: Rebrickable/BrickLink-style)</MudSelectItem>
    </MudSelect>

    <MudTextField @bind-Value="newMockName"
                  Label="MOC name"
                  Disabled="_loading"
                  Style="width:260px;margin-top:8px;" />

    <MudTextField @bind-Value="newMockComment"
                  Label="Comment"
                  Disabled="_loading"
                  Lines="3"
                  TextFieldStyle="MudBlazor.TextFieldStyle.Multiline" />

    <MudTextField @bind-Value="newMockWebSource"
                  Label="Web Source"
                  Disabled="_loading" />

    <div style="margin-top:8px;">
        <label>Upload MOC image (max 3MB)</label>
        <InputFile OnChange="OnImageSelected" accept="image/*" disabled="@_loading" />
    </div>

    @if (!string.IsNullOrEmpty(imagePreviewUrl))
    {
        <div style="margin-top:8px;">
            <img src="@imagePreviewUrl" alt="Mock Bild Vorschau"
                 style="max-width:200px;max-height:200px;border:1px solid #ccc;padding:2px;" />
        </div>
    }

    <br />
    <MudText Variant="body1">Upload Item List File:</MudText>

    <InputFile OnChange="OnFileSelected"
               accept="@GetAcceptString()"
               disabled="@_loading" />

    <MudText Typo="Typo.caption" Class="mt-2" Style="color:#666;">
        Supported: Rebrickable CSV (Part,Color,Quantity), BrickLink-style CSV (ITEMTYPE;ITEMID;COLOR;MINQTY;...), BrickLink XML, Rebrickable XML
    </MudText>

    <br />
    <br />

    @* Unmapped *@
    @if (unmappedItems.Count > 0)
    {
        <MudAlert Severity="Severity.Warning" Class="mb-4">
            Some items could not be mapped to existing MappedBricks (by PartNum). These items will be shown below.
        </MudAlert>
        <MudExpansionPanels>
            <MudExpansionPanel Text="Click here to see unmapped items" MaxHeight="450" Expanded="false">
                <MudPaper Class="pa-2 mb-2" Style="background:#fffbe6;border:1px solid #ffe082;">
                    <MudText Color="Color.Warning" Typo="Typo.subtitle2">
                        For the following items no MappedBrick was found:
                    </MudText>
                    <MudList T="string">
                        @foreach (var item in unmappedItems)
                        {
                            <MudListItem T="string">
                                <MudText>Part Number: <b>@item.PartNum</b>, ColorId: <b>@item.ColorId</b>, Qty: <b>@item.Quantity</b></MudText>
                            </MudListItem>
                        }
                    </MudList>
                </MudPaper>
            </MudExpansionPanel>
        </MudExpansionPanels>
    }

    @* Invalid FK IDs *@
    @if (invalidColorIds.Any() || invalidMappedBrickIds.Any())
    {
        <MudAlert Severity="Severity.Error" Class="mb-4">
            <b>Upload contains invalid IDs and cannot be saved.</b><br />
            @if (invalidColorIds.Any())
            {
                <div>Invalid BrickColorId(s): <b>@string.Join(", ", invalidColorIds.OrderBy(x => x))</b></div>
            }
            @if (invalidMappedBrickIds.Any())
            {
                <div>Invalid MappedBrickId(s): <b>@string.Join(", ", invalidMappedBrickIds.OrderBy(x => x))</b></div>
            }
            <div style="margin-top:6px;color:#666;">
                Fix: import/seed missing colors or adjust the file to only use known color IDs.
            </div>
        </MudAlert>
    }
    else if (unmappedItems.Count == 0 && uploadedItems.Count > 0)
    {
        <MudAlert Severity="Severity.Success" Class="mb-4">
            All items were successfully mapped and validated.
        </MudAlert>
    }

    <MudButton StartIcon="@Icons.Material.Filled.Add"
               Variant="Variant.Filled"
               Color="Color.Primary"
               OnClick="CreateMockFromUpload"
               Disabled="@(!fileReadyForUpload || _loading)"
               Class="ml-2 mt-2">
        Create new MOC
    </MudButton>

    <MudText Color="Color.Error">@uploadError</MudText>
</MudPaper>

<MudPaper Class="pa-4">
    <MudText Typo="Typo.h6">Your MOCs</MudText>

    <MudStack Row="true" Justify="Justify.FlexEnd" Spacing="2" Style="margin-bottom: 16px;">
    <MudButton StartIcon="@Icons.Material.Filled.Delete"
               Variant="Variant.Outlined"
               Color="Color.Error"
               OnClick="DeleteAllMocks"
               Disabled="_loading"
               Class="ml-2">
        Delete all MOCs
    </MudButton>
</MudStack>



    <MudList T="string">
        @if (userMocks == null)
        {
            <MudText>Loading...</MudText>
        }
        else if (!userMocks.Any())
        {
            <MudAlert Severity="Severity.Info">No MOCs found.</MudAlert>
        }
        else
        {
            using var scope = ServiceProvider.CreateScope();
            var db = scope.ServiceProvider.GetRequiredService<Data.AppDbContext>();
            var userUuid = UserService.GetTokenAsync().Result;
            var inventory = db.InventoryItems.Where(i => i.AppUser.Uuid == userUuid).ToList();

            @foreach (var mock in userMocks)
            {
                var totalParts = mock.Items?.Sum(i => i.Quantity) ?? 0;
                int ownedParts = 0;

                if (mock.Items != null)
                {
                    foreach (var item in mock.Items)
                    {
                        if (item.MappedBrickId != null && item.BrickColorId != null)
                        {
                            var inv = inventory
                                .Where(invItem => invItem.MappedBrickId == item.MappedBrickId && invItem.BrickColorId == item.BrickColorId)
                                .Sum(invItem => invItem.Quantity);

                            ownedParts += Math.Min(inv, item.Quantity);
                        }
                    }
                }

                var percent = (totalParts > 0) ? (int)Math.Floor(100.0 * ownedParts / totalParts) : 0;

                <MudListItem T="string" Style="display:flex;align-items:center;justify-content:space-between;cursor:pointer">
                    <div style="display:flex;align-items:center;flex:1;gap:12px;">
                        <img src="@ImageService.GetMockImagePath(mock)" alt="Mock Bild"
                             style="width:56px;height:56px;object-fit:contain;border:1px solid #ccc;background:#fff;padding:2px;border-radius:6px;" />
                        <span style="flex:1" @onclick="@(() => Nav.NavigateTo($"/mockdetail/{mock.Id}"))">
                            <MudText><b>@mock.Name</b> <span style="color:#888;font-size:0.95em">(@mock.MockType)</span></MudText>
                            <MudText Typo="Typo.caption">Items: @totalParts</MudText>
                            <MudText Typo="Typo.caption">Owned: @ownedParts / @totalParts (@percent%)</MudText>
                                <OwnershipProgress OwnedCount="@ownedParts" TotalCount="@totalParts" />


                            <MudProgressLinear Value="@percent" Color="@(percent == 100 ? Color.Success : Color.Primary)" Style="max-width:120px;height:8px;margin-top:2px;" />
                            @if (!string.IsNullOrWhiteSpace(mock.WebSource))
                            {
                                <MudText Typo="Typo.caption">
                                    <a href="@mock.WebSource" target="_blank" rel="noopener noreferrer" style="color:#1976d2;text-decoration:underline;">Web-Source</a>
                                </MudText>
                            }
                            @if (!string.IsNullOrWhiteSpace(mock.Comment))
                            {
                                <MudText Typo="Typo.caption" Style="color:#666;"><br />Comment: @mock.Comment</MudText>
                            }
                        </span>
                    </div>

                    <MudButton Variant="Variant.Outlined"
                               Color="Color.Error"
                               Size="Size.Small"
                               Style="margin-left:8px"
                               Disabled="_loading"
                               OnClick="@(() => DeleteMock(mock.Id))">
                        Delete
                    </MudButton>
                </MudListItem>
            }
        }
    </MudList>
</MudPaper>

@code {
    private static class Formats
    {
        public const string RebrickableCsv = "rebrickable_csv";
        public const string RebrickableXml = "rebrickable_xml";
        public const string BricklinkXml = "bricklink_xml";
        public const string CsvAuto = "csv_auto";
    }

    private List<Mock>? userMocks;

    private string uploadError = string.Empty;
    private string selectedFormat = Formats.RebrickableCsv;

    private string newMockName = string.Empty;
    private string newMockComment = string.Empty;
    private string newMockWebSource = string.Empty;

    private List<MockItem> uploadedItems = new();
    private IBrowserFile? uploadedFile = null;
    private bool fileReadyForUpload = false;

    private IBrowserFile? uploadedImage = null;
    private string imagePreviewUrl = string.Empty;

    private bool _loading = false;

    // Diagnose / harte Validierung
    private List<(string? PartNum, int? ColorId, int Quantity)> unmappedItems = new();
    private HashSet<int> invalidColorIds = new();
    private HashSet<int> invalidMappedBrickIds = new();

    // Page error like SetDetails
    private string? _error;
    private string? _errorDetails;
    private void SetError(Exception ex, string context = "")
    {
        _error = string.IsNullOrWhiteSpace(context)
            ? $"An error happened: {ex.Message}"
            : $"An error happened ({context}): {ex.Message}";
        _errorDetails = ex.ToString();
    }

    private string GetAcceptString()
    {
        // wir akzeptieren immer csv/xml; der User kann auch "falsch" wählen -> wir erkennen dann in Code
        return ".csv,.xml";
    }

    private async Task OnImageSelected(InputFileChangeEventArgs e)
    {
        uploadError = string.Empty;
        imagePreviewUrl = string.Empty;
        uploadedImage = null;

        var file = e.File;
        if (file == null) return;

        if (file.Size > 3 * 1024 * 1024)
        {
            uploadError = "The image can be max 3MB.";
            return;
        }

        uploadedImage = file;

        try
        {
            using var stream = file.OpenReadStream(3 * 1024 * 1024);
            using var ms = new MemoryStream();
            await stream.CopyToAsync(ms);
            var bytes = ms.ToArray();
            var base64 = Convert.ToBase64String(bytes);

            var mime = string.IsNullOrWhiteSpace(file.ContentType) ? "image/*" : file.ContentType;
            imagePreviewUrl = $"data:{mime};base64,{base64}";
        }
        catch (Exception ex)
        {
            uploadError = $"Error reading image: {ex.Message}";
        }
    }

    private async Task DeleteMock(int mockId)
    {
        if (_loading) return;

        try
        {
            var userUuid = await UserService.GetTokenAsync();
            if (string.IsNullOrEmpty(userUuid))
                return;

            using var scope = ServiceProvider.CreateScope();
            var db = scope.ServiceProvider.GetRequiredService<Data.AppDbContext>();

            var mock = db.Mocks.FirstOrDefault(m => m.Id == mockId && m.UserUuid == userUuid);
            if (mock != null)
            {
                ImageService.DeleteMockImage(mock);
                db.Mocks.Remove(mock);
                db.SaveChanges();
            }

            await LoadMocks();
        }
        catch (Exception ex)
        {
            SetError(ex, "DeleteMock");
            NotificationService.Error(_error);
        }
    }

    private async Task DeleteAllMocks()
    {
        if (_loading) return;

        try
        {
            var userUuid = await UserService.GetTokenAsync();
            if (string.IsNullOrEmpty(userUuid))
                return;

            using var scope = ServiceProvider.CreateScope();
            var db = scope.ServiceProvider.GetRequiredService<Data.AppDbContext>();

            var mocks = db.Mocks.Where(m => m.UserUuid == userUuid).ToList();
            if (mocks.Any())
            {
                foreach (var mock in mocks)
                    ImageService.DeleteMockImage(mock);

                db.Mocks.RemoveRange(mocks);
                db.SaveChanges();
            }

            await LoadMocks();
        }
        catch (Exception ex)
        {
            SetError(ex, "DeleteAllMocks");
            NotificationService.Error(_error);
        }
    }

    private bool _loaded = false;
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender || _loaded) return;

        _loaded = true;

        try
        {
            await LoadMocks();
        }
        catch (Exception ex)
        {
            SetError(ex, "LoadMocks");
        }
        finally
        {
            StateHasChanged();
        }
    }

    private async Task LoadMocks()
    {
        using var scope = ServiceProvider.CreateScope();
        var db = scope.ServiceProvider.GetRequiredService<Data.AppDbContext>();
        var userUuid = await UserService.GetTokenAsync();

        if (string.IsNullOrEmpty(userUuid))
        {
            userMocks = new();
            return;
        }

        userMocks = db.Mocks
            .Where(m => m.UserUuid == userUuid)
            .Include(m => m.Items)
            .ToList();
    }

    private async Task OnFileSelected(InputFileChangeEventArgs e)
    {
        if (_loading) return;

        _error = null;
        _errorDetails = null;

        uploadError = string.Empty;
        uploadedFile = e.File;

        fileReadyForUpload = false;
        uploadedItems.Clear();
        unmappedItems.Clear();
        invalidColorIds.Clear();
        invalidMappedBrickIds.Clear();

        if (uploadedFile == null)
            return;

        _loading = true;
        await InvokeAsync(StateHasChanged);
        await Task.Delay(50);
        LoadingService.Show("Analyzing file...");

        try
        {
            using var stream = uploadedFile.OpenReadStream();
            using var reader = new StreamReader(stream);

            var content = await reader.ReadToEndAsync();
            if (string.IsNullOrWhiteSpace(content))
            {
                uploadError = "File is empty.";
                return;
            }

            using var scope = ServiceProvider.CreateScope();
            var db = scope.ServiceProvider.GetRequiredService<Data.AppDbContext>();

            // Caches für Validierung / Mapping
            var validColorSet = await db.BrickColors.AsNoTracking().Select(c => c.Id).ToHashSetAsync();

            // --- Detect by content/ext ---
            var ext = Path.GetExtension(uploadedFile.Name).ToLowerInvariant();
            var looksLikeXml = ext == ".xml" || content.TrimStart().StartsWith("<");

            var items = new List<MockItem>();

            if (looksLikeXml)
            {
                // XML: Bricklink oder Rebrickable (ähnlich)
                items = ParseXmlToMockItems(content, db, validColorSet);
            }
            else
            {
                // CSV: Auto (Rebrickable comma) oder BrickLink-style semicolon
                items = ParseCsvToMockItems(content, db, validColorSet);
            }

            uploadedItems = items;
            fileReadyForUpload = uploadedItems.Count > 0;

            if (!fileReadyForUpload)
                uploadError = "No valid items found in file.";
        }
        catch (Exception ex)
        {
            SetError(ex, "OnFileSelected");
            uploadError = _error ?? $"Error parsing file: {ex.Message}";
        }
        finally
        {
            LoadingService.Hide();
            _loading = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private List<MockItem> ParseCsvToMockItems(string csv, Data.AppDbContext db, HashSet<int> validColorSet)
    {
        var items = new List<MockItem>();

        // detect delimiter by header line
        var lines = csv.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
        if (lines.Length < 2)
            return items;

        var headerLine = lines[0].Trim();

        var isBricklinkStyle = headerLine.Contains("ITEMTYPE", StringComparison.OrdinalIgnoreCase)
                               && headerLine.Contains("ITEMID", StringComparison.OrdinalIgnoreCase)
                               && headerLine.Contains("COLOR", StringComparison.OrdinalIgnoreCase);

        if (isBricklinkStyle)
        {
            // BrickLink-style CSV: ITEMTYPE;ITEMID;COLOR;...;MINQTY;...
            var header = headerLine.Split(';');

            int itemIdIdx = Array.FindIndex(header, h => string.Equals(h, "ITEMID", StringComparison.OrdinalIgnoreCase));
            int colorIdx  = Array.FindIndex(header, h => string.Equals(h, "COLOR", StringComparison.OrdinalIgnoreCase));
            int qtyIdx    = Array.FindIndex(header, h => string.Equals(h, "MINQTY", StringComparison.OrdinalIgnoreCase));

            if (itemIdIdx < 0 || colorIdx < 0 || qtyIdx < 0)
                return items;

            for (int i = 1; i < lines.Length; i++)
            {
                var cols = lines[i].Split(';');
                int maxIdx = Math.Max(itemIdIdx, Math.Max(colorIdx, qtyIdx));
                if (cols.Length <= maxIdx) continue;

                var partNum = cols[itemIdIdx]?.Trim();
                var colorId = int.TryParse(cols[colorIdx]?.Trim(), out var cid) ? cid : (int?)null;
                var qty = int.TryParse(cols[qtyIdx]?.Trim(), out var q) ? q : 1;

                AddParsedRow(items, db, validColorSet, partNum, colorId, qty);
            }

            return items;
        }

        // Rebrickable CSV: Part,Color,Quantity (comma)
        var header2 = headerLine.Split(',');
        int partIdx = Array.FindIndex(header2, h => string.Equals(h.Trim(), "Part", StringComparison.OrdinalIgnoreCase));
        int color2Idx = Array.FindIndex(header2, h => string.Equals(h.Trim(), "Color", StringComparison.OrdinalIgnoreCase));
        int qty2Idx = Array.FindIndex(header2, h => string.Equals(h.Trim(), "Quantity", StringComparison.OrdinalIgnoreCase));

        if (partIdx < 0 || color2Idx < 0 || qty2Idx < 0)
            return items;

        for (int i = 1; i < lines.Length; i++)
        {
            var cols = lines[i].Split(',');
            int maxIdx = Math.Max(partIdx, Math.Max(color2Idx, qty2Idx));
            if (cols.Length <= maxIdx) continue;

            var partNum = cols[partIdx]?.Trim();
            var colorId = int.TryParse(cols[color2Idx]?.Trim(), out var cid) ? cid : (int?)null;
            var qty = int.TryParse(cols[qty2Idx]?.Trim(), out var q) ? q : 1;

            AddParsedRow(items, db, validColorSet, partNum, colorId, qty);
        }

        return items;
    }

    private List<MockItem> ParseXmlToMockItems(string xml, Data.AppDbContext db, HashSet<int> validColorSet)
    {
        var items = new List<MockItem>();

        XDocument doc;
        try
        {
            doc = XDocument.Parse(xml);
        }
        catch
        {
            uploadError = "Invalid XML file.";
            return items;
        }

        // Support: <ITEM> blocks (Bricklink & many Rebrickable exports look similar)
        var itemNodes = doc.Descendants("ITEM").ToList();
        if (!itemNodes.Any())
        {
            // fallback: try any nodes named "Part" etc (very defensive)
            // If no known structure -> return empty
            return items;
        }

        foreach (var x in itemNodes)
        {
            var partNum = x.Element("ITEMID")?.Value?.Trim();
            var colorId = int.TryParse(x.Element("COLOR")?.Value, out var cid) ? cid : (int?)null;

            // qty keys differ
            int qty =
                int.TryParse(x.Element("MINQTY")?.Value, out var q1) ? q1 :
                int.TryParse(x.Element("QTY")?.Value, out var q2) ? q2 :
                int.TryParse(x.Element("QUANTITY")?.Value, out var q3) ? q3 :
                1;

            AddParsedRow(items, db, validColorSet, partNum, colorId, qty);
        }

        return items;
    }

    private void AddParsedRow(List<MockItem> items, Data.AppDbContext db, HashSet<int> validColorSet,
                              string? partNum, int? colorId, int qty)
    {
        int? mappedBrickId = null;

        if (!string.IsNullOrWhiteSpace(partNum))
        {
            var mapped = db.MappedBricks.FirstOrDefault(b => b.LegoPartNum == partNum);
            if (mapped != null)
                mappedBrickId = mapped.Id;
        }

        if (mappedBrickId == null)
            unmappedItems.Add((partNum, colorId, qty));

        if (colorId.HasValue && !validColorSet.Contains(colorId.Value))
            invalidColorIds.Add(colorId.Value);

        // Wir erstellen trotzdem MockItem-Liste (für Anzeige/Debug); beim Speichern wird hart abgebrochen
        items.Add(new MockItem
        {
            ExternalPartNum = partNum,
            Quantity = qty <= 0 ? 1 : qty,
            BrickColorId = colorId,
            MappedBrickId = mappedBrickId
        });
    }

    private async Task CreateMockFromUpload()
    {
        if (_loading) return;

        _error = null;
        _errorDetails = null;

        uploadError = string.Empty;

        if (string.IsNullOrWhiteSpace(newMockName))
        {
            uploadError = "Please provide a name for the MOC.";
            return;
        }

        if (uploadedFile == null || uploadedItems == null || uploadedItems.Count == 0)
        {
            uploadError = "Please upload a valid item list file.";
            return;
        }

        _loading = true;
        await InvokeAsync(StateHasChanged);
        await Task.Delay(100);
        LoadingService.Show("Creating your MOC...");

        try
        {
            using var scope = ServiceProvider.CreateScope();
            var db = scope.ServiceProvider.GetRequiredService<Data.AppDbContext>();

            var userUuid = await UserService.GetTokenAsync();
            if (string.IsNullOrEmpty(userUuid))
            {
                uploadError = "Not logged in.";
                return;
            }

            // ===== HARD VALIDATION (abort) =====
            var validBrickIds = await db.MappedBricks.AsNoTracking().Select(b => b.Id).ToHashSetAsync();
            var validColorIds = await db.BrickColors.AsNoTracking().Select(c => c.Id).ToHashSetAsync();

            invalidMappedBrickIds.Clear();
            invalidColorIds.Clear();

            foreach (var it in uploadedItems)
            {
                if (it.MappedBrickId.HasValue && it.MappedBrickId.Value > 0 && !validBrickIds.Contains(it.MappedBrickId.Value))
                    invalidMappedBrickIds.Add(it.MappedBrickId.Value);

                if (it.BrickColorId.HasValue && it.BrickColorId.Value > 0 && !validColorIds.Contains(it.BrickColorId.Value))
                    invalidColorIds.Add(it.BrickColorId.Value);
            }

            // Wenn es unmapped gibt (MappedBrickId null) -> ebenfalls hart abbrechen? (dein Wunsch war "invalid IDs")
            // Wir brechen hier hart ab, wenn entweder invalid FK IDs ODER unmapped vorhanden sind.
            // Wenn du unmapped weiterhin "ignorieren" willst, sag kurz Bescheid.
            if (invalidColorIds.Any() || invalidMappedBrickIds.Any() || unmappedItems.Any())
            {
                var parts = new List<string>();
                if (unmappedItems.Any())
                    parts.Add($"Unmapped parts: {unmappedItems.Count}");
                if (invalidColorIds.Any())
                    parts.Add($"Invalid BrickColorId(s): {string.Join(", ", invalidColorIds.OrderBy(x => x))}");
                if (invalidMappedBrickIds.Any())
                    parts.Add($"Invalid MappedBrickId(s): {string.Join(", ", invalidMappedBrickIds.OrderBy(x => x))}");

                uploadError = "Cannot create MOC. Fix these issues first:\n" + string.Join("\n", parts);
                NotificationService.Error("Creating MOC failed (invalid IDs).");
                return;
            }

            // Nur gültige Items speichern
            var validItems = uploadedItems
                .Where(i => i.MappedBrickId != null && i.BrickColorId != null && i.Quantity > 0)
                .ToList();

            var mock = new Mock
            {
                Name = newMockName.Trim(),
                UserUuid = userUuid,
                MockType = selectedFormat,
                Items = validItems,
                Comment = string.IsNullOrWhiteSpace(newMockComment) ? null : newMockComment.Trim(),
                WebSource = string.IsNullOrWhiteSpace(newMockWebSource) ? null : newMockWebSource.Trim(),
            };

            db.Mocks.Add(mock);
            db.SaveChanges();

            if (uploadedImage != null)
            {
                try
                {
                    await ImageService.SaveMockImageAsync(uploadedImage, userUuid, mock.Id);
                    db.SaveChanges();
                }
                catch (Exception exImg)
                {
                    // Bildfehler soll nicht den ganzen Mock killen
                    NotificationService.Error($"Image could not be saved: {exImg.Message}");
                }
            }

            // Reset UI
            newMockName = string.Empty;
            newMockComment = string.Empty;
            newMockWebSource = string.Empty;
            uploadedFile = null;
            uploadedItems.Clear();
            fileReadyForUpload = false;
            unmappedItems.Clear();
            invalidColorIds.Clear();
            invalidMappedBrickIds.Clear();
            uploadedImage = null;
            imagePreviewUrl = string.Empty;

            await LoadMocks();

            NotificationService.Success("MOC successfully created.");
        }
        catch (Exception ex)
        {
            SetError(ex, "CreateMockFromUpload");
            uploadError = _error ?? $"Error while saving: {ex.Message}";
            NotificationService.Error("Creating MOC failed.");
        }
        finally
        {
            LoadingService.Hide();
            _loading = false;
            await InvokeAsync(StateHasChanged);
        }
    }
}
