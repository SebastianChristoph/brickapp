@page "/mymocs"

@using System.Xml.Linq
@using Microsoft.EntityFrameworkCore
@using brickapp.Data.Entities
@using Microsoft.AspNetCore.Components.Forms
@using brickapp.Data.Services
@using MudBlazor
@using brickapp.Components.Shared.PartsListUpload
@using brickapp.Helpers
@inject NavigationManager Nav
@inject IServiceProvider ServiceProvider
@inject brickapp.Data.Services.ImageService ImageService
@inject brickapp.Data.Services.UserService UserService
@inject brickapp.Data.Services.LoadingService LoadingService
@inject brickapp.Data.Services.NotificationService NotificationService

@using IBrowserFile = Microsoft.AspNetCore.Components.Forms.IBrowserFile

<MudText Typo="Typo.h4" GutterBottom="true">My MOCs</MudText>

@if (!string.IsNullOrWhiteSpace(_error))
{
    <MudAlert Severity="Severity.Error" Variant="Variant.Filled" Class="mb-4">
        @_error
        @if (!string.IsNullOrWhiteSpace(_errorDetails))
        {
            <MudDivider Class="my-2" />
            <MudText Typo="Typo.caption" Style="white-space:pre-wrap;">@_errorDetails</MudText>
        }
    </MudAlert>
}

<MudPaper Class="pa-4 mb-4">
    <MudText Typo="Typo.h6">Upload a new MOC</MudText>

    <MudTextField @bind-Value="newMockName"
                  Label="MOC name"
                  Disabled="_loading"
                  Style="width:260px;margin-top:8px;" />

    <MudTextField @bind-Value="newMockComment"
                  Label="Comment"
                  Disabled="_loading"
                  Lines="3"
                  TextFieldStyle="MudBlazor.TextFieldStyle.Multiline" />

    <MudTextField @bind-Value="newMockWebSource"
                  Label="Web Source"
                  Disabled="_loading" />

    <div style="margin-top:8px;">
        <label>Upload MOC image (max 3MB)</label>
        <InputFile OnChange="OnImageSelected" accept="image/*" disabled="@_loading" />
    </div>

    @if (!string.IsNullOrEmpty(imagePreviewUrl))
    {
        <div style="margin-top:8px;">
            <img src="@imagePreviewUrl" alt="Mock Bild Vorschau"
                 style="max-width:200px;max-height:200px;border:1px solid #ccc;padding:2px;" />
        </div>
    }

    <MudDivider Class="my-3" />
<PartsListUploader Title="Upload Item List File"
                   HelpText="Supported: Rebrickable CSV, Rebrickable XML, BrickLink XML."
                   Disabled="_loading"
                   Formats="@_mocFormats"
                   FormatLabelFunc="MocFormatLabel"
                   ShowAddButton="false"
                   ClearButtonText="Clear upload"
                   OnParsed="OnMocParsed" />
    @if (!string.IsNullOrWhiteSpace(uploadError))
    {
        <MudText Color="Color.Error" Class="mt-2">@uploadError</MudText>
    }

    <MudButton StartIcon="@Icons.Material.Filled.Add"
               Variant="Variant.Filled"
               Color="Color.Primary"
               OnClick="CreateMockFromUpload"
               Disabled="@(!fileReadyForUpload || _loading)"
               Class="ml-2 mt-3">
        Create new MOC
    </MudButton>
</MudPaper>

<MudPaper Class="pa-4">
    <MudText Typo="Typo.h6">Your MOCs</MudText>

    <MudStack Row="true" Justify="Justify.FlexEnd" Spacing="2" Style="margin-bottom: 16px;">
        <MudButton StartIcon="@Icons.Material.Filled.Delete"
                   Variant="Variant.Outlined"
                   Color="Color.Error"
                   OnClick="DeleteAllMocks"
                   Disabled="_loading"
                   Class="ml-2">
            Delete all MOCs
        </MudButton>
    </MudStack>

    <MudList T="string">
        @if (userMocks == null)
        {
            <MudText>Loading...</MudText>
        }
        else if (!userMocks.Any())
        {
            <MudAlert Severity="Severity.Info">No MOCs found.</MudAlert>
        }
        else
        {
            @foreach (var mock in userMocks)
            {
                var totalParts = mock.Items?.Sum(i => i.Quantity) ?? 0;
                <MudListItem T="string" Style="display:flex;align-items:center;justify-content:space-between;cursor:pointer">
                    <div style="display:flex;align-items:center;flex:1;gap:12px;">
                        <img src="@ImageService.GetMockImagePath(mock)" alt="Mock Bild"
                             style="width:56px;height:56px;object-fit:contain;border:1px solid #ccc;background:#fff;padding:2px;border-radius:6px;" />
                        <span style="flex:1" @onclick="@(() => Nav.NavigateTo($"/mockdetail/{mock.Id}"))">
                            <MudText><b>@mock.Name</b> <span style="color:#888;font-size:0.95em">(@mock.MockType)</span></MudText>
                            <MudText Typo="Typo.caption">Items: @totalParts</MudText>
                        </span>
                    </div>
                    <MudButton Variant="Variant.Outlined" Color="Color.Error" Size="Size.Small" OnClick="@(() => DeleteMock(mock.Id))">Delete</MudButton>
                </MudListItem>
            }
        }
    </MudList>
</MudPaper>

@code {
    private readonly PartsUploadFormat[] _mocFormats = new[]
    {
        PartsUploadFormat.RebrickableCsv,
        PartsUploadFormat.RebrickableXml,
        PartsUploadFormat.BricklinkXml
    };

    private string MocFormatLabel(PartsUploadFormat f) => f switch
    {
        PartsUploadFormat.RebrickableCsv => "Rebrickable CSV (Part,Color,Quantity)",
        PartsUploadFormat.RebrickableXml => "Rebrickable XML",
        PartsUploadFormat.BricklinkXml => "BrickLink XML",
        _ => f.ToString()
    };

    private List<Mock>? userMocks;
    private string uploadError = string.Empty;
    private string newMockName = string.Empty;
    private string newMockComment = string.Empty;
    private string newMockWebSource = string.Empty;
    private List<MockItem> uploadedItems = new();
    private bool fileReadyForUpload = false;
    private IBrowserFile? uploadedImage = null;
    private string imagePreviewUrl = string.Empty;
    private bool _loading = false;
    private string? _error;
    private string? _errorDetails;

    private void SetError(Exception ex, string context = "")
    {
        _error = string.IsNullOrWhiteSpace(context) ? $"Error: {ex.Message}" : $"Error ({context}): {ex.Message}";
        _errorDetails = ex.ToString();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender) { await LoadMocks(); StateHasChanged(); }
    }

    private async Task LoadMocks()
    {
        using var scope = ServiceProvider.CreateScope();
        var db = scope.ServiceProvider.GetRequiredService<Data.AppDbContext>();
        var userUuid = await UserService.GetTokenAsync();
        if (string.IsNullOrEmpty(userUuid)) return;
        userMocks = await db.Mocks.Where(m => m.UserUuid == userUuid).Include(m => m.Items).ToListAsync();
    }

private Task OnMocParsed(ParseResult<ParsedPart> result)
{
    // Hier baust du aus ParsedPart deine MockItems
    uploadedItems = result.MappedItems
        .Select(p => new MockItem
        {
            MappedBrickId = p.MappedBrickId,
            BrickColorId = p.BrickColorId,
            Quantity = p.Quantity,
            ExternalPartNum = p.ExternalPartNum
        })
        .ToList();

    // Wenn du vorher Unmapped/Invalid etc. in der Page angezeigt hast:
    //_lastParseResult = result; // optional für UI

    return Task.CompletedTask;
}


    private async Task<ParseResult<MockItem>> ParseMocUploadAsync(string content, PartsUploadFormat format)
    {
        var (rows, invalidRows, invalidColorIdsFromFile) = format switch
        {
            PartsUploadFormat.RebrickableCsv => ParseRebrickableCsv_Rows(content),
            PartsUploadFormat.RebrickableXml => ParseRebrickableXml_Rows(content),
            PartsUploadFormat.BricklinkXml => ParseBricklinkXml_Rows(content),
            _ => (new List<(string PartNum, int ColorIdFromFile, int Qty, string ColorMode)>(), new List<(string?, int?, int, string)>(), new HashSet<int>())
        };

        return await MapRowsToMockItemsAsync(rows, invalidRows, invalidColorIdsFromFile);
    }

    private async Task<ParseResult<MockItem>> MapRowsToMockItemsAsync(
        List<(string PartNum, int ColorIdFromFile, int Qty, string ColorMode)> rows,
        List<(string? PartNum, int? ColorId, int Qty, string Reason)> invalidRows,
        HashSet<int> invalidColorIdsFromFile)
    {
        var result = new ParseResult<MockItem> { 
            InvalidColorIds = new HashSet<int>(invalidColorIdsFromFile),
            InvalidRows = invalidRows.Select(x => new InvalidRow(x.PartNum, x.ColorId, x.Qty, x.Reason)).ToList()
        };

        using var scope = ServiceProvider.CreateScope();
        var db = scope.ServiceProvider.GetRequiredService<Data.AppDbContext>();

        // LADE CACHES FRISCH (Das löst das Problem, dass Items nicht gefunden werden)
        var allBricks = await db.MappedBricks.AsNoTracking().ToListAsync();
        var brickMap = allBricks
            .Where(b => !string.IsNullOrEmpty(b.LegoPartNum))
            .GroupBy(b => b.LegoPartNum!.Trim())
            .ToDictionary(g => g.Key, g => g.First().Id, StringComparer.OrdinalIgnoreCase);

        var allColors = await db.BrickColors.AsNoTracking().ToListAsync();
        var rbToDbColor = allColors.ToDictionary(c => c.RebrickableColorId, c => c.Id);
        var nameToDbColor = allColors.Where(c => c.Name != null)
            .GroupBy(c => c.Name!.Trim())
            .ToDictionary(g => g.Key, g => g.First().Id, StringComparer.OrdinalIgnoreCase);

        foreach (var (partNum, colorIdFromFile, qty, colorMode) in rows)
        {
            var partTrim = partNum.Trim();
            if (!brickMap.TryGetValue(partTrim, out var mappedBrickId))
            {
                result.Unmapped.Add(new UnmappedRow(partTrim, colorIdFromFile, qty));
                continue;
            }

            int? dbColorId = null;
            if (colorMode == "rebrickable")
            {
                if (rbToDbColor.TryGetValue(colorIdFromFile, out var cid)) dbColorId = cid;
            }
            else // bricklink
            {
                var blName = BricklinkColorMap.GetBrickColorName(colorIdFromFile);
                if (!string.IsNullOrEmpty(blName) && nameToDbColor.TryGetValue(blName.Trim(), out var cid)) dbColorId = cid;
            }

            if (dbColorId.HasValue)
            {
                result.MappedItems.Add(new MockItem { 
                    MappedBrickId = mappedBrickId, 
                    BrickColorId = dbColorId.Value, 
                    Quantity = qty, 
                    ExternalPartNum = partTrim 
                });
            }
            else
            {
                result.InvalidColorIds.Add(colorIdFromFile);
            }
        }

        // Gruppieren
        result.MappedItems = result.MappedItems
            .GroupBy(i => new { i.MappedBrickId, i.BrickColorId })
            .Select(g => { var f = g.First(); f.Quantity = g.Sum(x => x.Quantity); return f; })
            .ToList();

        return result;
    }

    // ==========================================
    // PARSER METHODEN (Vollständig)
    // ==========================================

    private (List<(string PartNum, int ColorIdFromFile, int Qty, string ColorMode)> rows, List<(string? PartNum, int? ColorId, int Qty, string Reason)> invalidRows, HashSet<int> invalidColorIds) ParseRebrickableCsv_Rows(string csv)
    {
        var rows = new List<(string, int, int, string)>();
        var lines = csv.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
        if (lines.Length < 2) return (rows, new(), new());

        var header = lines[0].Split(',').Select(x => x.Trim()).ToArray();
        int pIdx = Array.FindIndex(header, h => h.Equals("Part", StringComparison.OrdinalIgnoreCase));
        int cIdx = Array.FindIndex(header, h => h.Equals("Color", StringComparison.OrdinalIgnoreCase));
        int qIdx = Array.FindIndex(header, h => h.Equals("Quantity", StringComparison.OrdinalIgnoreCase));

        if (pIdx < 0 || cIdx < 0 || qIdx < 0) return (rows, new(), new());

        for (int i = 1; i < lines.Length; i++)
        {
            var cols = lines[i].Split(',');
            if (cols.Length <= Math.Max(pIdx, Math.Max(cIdx, qIdx))) continue;
            if (int.TryParse(cols[cIdx], out var c) && int.TryParse(cols[qIdx], out var q))
                rows.Add((cols[pIdx].Trim(), c, q, "rebrickable"));
        }
        return (rows, new(), new());
    }

    private (List<(string PartNum, int ColorIdFromFile, int Qty, string ColorMode)> rows, List<(string? PartNum, int? ColorId, int Qty, string Reason)> invalidRows, HashSet<int> invalidColorIds) ParseBricklinkXml_Rows(string xml)
    {
        var rows = new List<(string, int, int, string)>();
        try {
            var doc = XDocument.Parse(xml);
            var items = doc.Descendants().Where(x => x.Name.LocalName.Equals("ITEM", StringComparison.OrdinalIgnoreCase));
            foreach (var it in items) {
                var id = it.Elements().FirstOrDefault(e => e.Name.LocalName.Equals("ITEMID", StringComparison.OrdinalIgnoreCase))?.Value;
                var col = it.Elements().FirstOrDefault(e => e.Name.LocalName.Equals("COLOR", StringComparison.OrdinalIgnoreCase))?.Value;
                var qty = it.Elements().FirstOrDefault(e => e.Name.LocalName.Equals("MINQTY", StringComparison.OrdinalIgnoreCase) || e.Name.LocalName.Equals("QTY", StringComparison.OrdinalIgnoreCase))?.Value;
                if (id != null && int.TryParse(col, out var c) && int.TryParse(qty, out var q))
                    rows.Add((id.Trim(), c, q, "bricklink"));
            }
        } catch { }
        return (rows, new(), new());
    }

    private (List<(string PartNum, int ColorIdFromFile, int Qty, string ColorMode)> rows, List<(string? PartNum, int? ColorId, int Qty, string Reason)> invalidRows, HashSet<int> invalidColorIds) ParseRebrickableXml_Rows(string xml)
    {
        // Rebrickable XMLs sind oft wie Bricklink XMLs aufgebaut
        return ParseBricklinkXml_Rows(xml);
    }

    private async Task CreateMockFromUpload()
    {
        if (_loading || uploadedItems.Count == 0) return;
        _loading = true;
        LoadingService.Show("Creating MOC...");
        try {
            using var scope = ServiceProvider.CreateScope();
            var db = scope.ServiceProvider.GetRequiredService<Data.AppDbContext>();
            var userUuid = await UserService.GetTokenAsync();
            
            var mock = new Mock { 
                Name = newMockName, 
                Comment = newMockComment, 
                WebSource = newMockWebSource, 
                UserUuid = userUuid, 
                MockType = "Upload" 
            };
            db.Mocks.Add(mock);
            await db.SaveChangesAsync();

            foreach (var item in uploadedItems) {
                item.MockId = mock.Id;
                db.MockItems.Add(item);
            }

            if (uploadedImage != null) {
                await ImageService.SaveMockImageAsync(uploadedImage, userUuid, mock.Id);
            }

            await db.SaveChangesAsync();
            NotificationService.Success("MOC created!");
            newMockName = ""; uploadedItems.Clear(); fileReadyForUpload = false;
            await LoadMocks();
        } catch (Exception ex) { SetError(ex, "Create"); }
        finally { LoadingService.Hide(); _loading = false; }
    }

    private async Task OnImageSelected(InputFileChangeEventArgs e)
    {
        uploadedImage = e.File;
        var stream = uploadedImage.OpenReadStream(3 * 1024 * 1024);
        var ms = new MemoryStream();
        await stream.CopyToAsync(ms);
        imagePreviewUrl = $"data:{e.File.ContentType};base64,{Convert.ToBase64String(ms.ToArray())}";
    }

    private async Task DeleteMock(int id) { /* Bestehende Logik ... */ }
    private async Task DeleteAllMocks() { /* Bestehende Logik ... */ }
}