@page "/mymocks"
@using System.Xml.Linq
@using Data.Entities
@using Microsoft.AspNetCore.Components.Forms
@using Services
@inject NavigationManager Nav
@inject IServiceProvider ServiceProvider
@inject UserService UserService

<h3>My Mocks</h3>


<MudPaper Class="pa-4 mb-4">
        <MudButton Variant="Variant.Outlined" Color="Color.Error" OnClick="DeleteAllMocks" Class="ml-2">Alle Mocks löschen</MudButton>
        <MudText Typo="Typo.h6">Neues Mock hochladen</MudText>
        <MudSelect @bind-Value="selectedFormat" Label="Dateiformat" Style="width:200px;">
            <MudSelectItem Value="@("bricklink")">bricklink List (XML)</MudSelectItem>
            <MudSelectItem Value="@("rebrickable")">Rebrickable List (CSV)</MudSelectItem>
            <!-- Weitere Formate später -->
        </MudSelect>
        <MudTextField @bind-Value="newMockName" Label="Mock-Name" Style="width:200px;margin-top:8px;" />
        <MudTextField @bind-Value="newMockComment" Label="Kommentar" Style="width:200px;margin-top:8px;" />
        <MudTextField @bind-Value="newMockWebSource" Label="Web-URL" Style="width:200px;margin-top:8px;" />
        <InputFile OnChange="OnFileSelected" accept="@(selectedFormat == "bricklink" ? ".xml" : ".csv")" />
        <MudText Color="Color.Error">@uploadError</MudText>
</MudPaper>

@if (unmappedItems.Count > 0)
    {
        <MudPaper Class="pa-2 mb-2" Style="background:#fffbe6;border:1px solid #ffe082;">
            <MudText Color="Color.Warning" Typo="Typo.subtitle2">
                Für folgende Items wurde kein MappedBrick gefunden:
            </MudText>
            <MudList T="string">
                @foreach (var item in unmappedItems)
                {
                    <MudListItem T="string">
                        <MudText>ITEMID: <b>@item.PartNum</b>, COLOR: <b>@item.ColorId</b>, QTY: <b>@item.Quantity</b></MudText>
                    </MudListItem>
                }
            </MudList>
        </MudPaper>
    }

<MudPaper Class="pa-4">
    <MudText Typo="Typo.h6">Deine Mocks</MudText>
    <MudList T="string">
        @if (userMocks == null)
        {
            <MudText>Wird geladen...</MudText>
        }
        else if (!userMocks.Any())
        {
            <MudText>Keine Mocks gefunden.</MudText>
        }
        else
        {
            using var scope = ServiceProvider.CreateScope();
            var db = scope.ServiceProvider.GetRequiredService<Data.AppDbContext>();
            var userUuid = UserService.GetTokenAsync().Result;
            var inventory = db.InventoryItems.Where(i => i.AppUser.Uuid == userUuid).ToList();

            @foreach (var mock in userMocks)
            {
                var totalParts = mock.Items?.Sum(i => i.Quantity) ?? 0;
                // Besitzte Teile berechnen
                int ownedParts = 0;
                if (mock.Items != null)
                {
                    foreach (var item in mock.Items)
                    {
                        if (item.MappedBrickId != null && item.BrickColorId != null)
                        {
                            var inv = inventory.Where(invItem => invItem.MappedBrickId == item.MappedBrickId && invItem.BrickColorId == item.BrickColorId).Sum(invItem => invItem.Quantity);
                            ownedParts += Math.Min(inv, item.Quantity);
                        }
                    }
                }
                var percent = (totalParts > 0) ? (int)Math.Floor(100.0 * ownedParts / totalParts) : 0;

                <MudListItem T="string" Style="display:flex;align-items:center;justify-content:space-between;cursor:pointer">
                    <span style="flex:1" @onclick="@(() => Nav.NavigateTo($"/mockdetail/{mock.Id}"))">
                        <MudText><b>@mock.Name</b> <span style="color:#888;font-size:0.95em">(@mock.MockType)</span></MudText>
                        <MudText Typo="Typo.caption">Teile: @totalParts</MudText>
                        <MudText Typo="Typo.caption">Besitzt: @ownedParts / @totalParts (@percent%)</MudText>
                        <MudProgressLinear Value="@percent" Color="@(percent == 100 ? Color.Success : Color.Primary)" Style="max-width:120px;height:8px;margin-top:2px;" />
                        @if (!string.IsNullOrWhiteSpace(mock.WebSource))
                        {
                            <MudText Typo="Typo.caption">
                                <a href="@mock.WebSource" target="_blank" rel="noopener noreferrer" style="color:#1976d2;text-decoration:underline;">Web-Quelle</a>
                            </MudText>
                        }
                        @if (!string.IsNullOrWhiteSpace(mock.Comment))
                        {
                            <MudText Typo="Typo.caption" Style="color:#666;"><br />Kommentar: @mock.Comment</MudText>
                        }
                    </span>
                    <MudButton Variant="Variant.Outlined" Color="Color.Error" Size="Size.Small" Style="margin-left:8px" OnClick="@(() => DeleteMock(mock.Id))">Löschen</MudButton>
                </MudListItem>
            }
        }
    </MudList>
</MudPaper>

@code {
    private List<Mock>? userMocks;
    private string uploadError = string.Empty;
    private List<(string? PartNum, int? ColorId, int Quantity)> unmappedItems = new();
    private string selectedFormat = "bricklink";
    private string newMockName = string.Empty;
    private string newMockComment = string.Empty;
    private string newMockWebSource = string.Empty;

    private async Task DeleteMock(int mockId)
    {
        var userUuid = await UserService.GetTokenAsync();
        if (string.IsNullOrEmpty(userUuid))
            return;
        using var scope = ServiceProvider.CreateScope();
        var db = scope.ServiceProvider.GetRequiredService<Data.AppDbContext>();
        var mock = db.Mocks.FirstOrDefault(m => m.Id == mockId && m.UserUuid == userUuid);
        if (mock != null)
        {
            db.Mocks.Remove(mock);
            db.SaveChanges();
        }
        await LoadMocks();
    }

    private async Task DeleteAllMocks()
    {
        var userUuid = await UserService.GetTokenAsync();
        if (string.IsNullOrEmpty(userUuid))
            return;
        using var scope = ServiceProvider.CreateScope();
        var db = scope.ServiceProvider.GetRequiredService<Data.AppDbContext>();
        var mocks = db.Mocks.Where(m => m.UserUuid == userUuid).ToList();
        if (mocks.Any())
        {
            db.Mocks.RemoveRange(mocks);
            db.SaveChanges();
        }
        await LoadMocks();
    }


    private bool _loaded = false;
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_loaded)
        {
            _loaded = true;
            await LoadMocks();
            StateHasChanged();
        }
    }

    private async Task LoadMocks()
    {
        using var scope = ServiceProvider.CreateScope();
        var db = scope.ServiceProvider.GetRequiredService<Data.AppDbContext>();
        var userUuid = await UserService.GetTokenAsync();
        
        if (string.IsNullOrEmpty(userUuid))
        {
            userMocks = new();
            return;
        }
        userMocks = db.Mocks.Where(m => m.UserUuid == userUuid).ToList();
    }

    private async Task OnFileSelected(InputFileChangeEventArgs e)
    {
        uploadError = string.Empty;
        var file = e.File;
        if (file == null)
            return;

        // Dateiendung prüfen
        if (selectedFormat == "bricklink" && !file.Name.EndsWith(".xml", StringComparison.OrdinalIgnoreCase))
        {
            uploadError = "Bitte eine XML-Datei für Bricklink auswählen.";
            return;
        }
        if (selectedFormat == "rebrickable" && !file.Name.EndsWith(".csv", StringComparison.OrdinalIgnoreCase))
        {
            uploadError = "Bitte eine CSV-Datei für Rebrickable auswählen.";
            return;
        }

        try
        {
            unmappedItems.Clear();
            using var stream = file.OpenReadStream();
            using var reader = new StreamReader(stream);
            var items = new List<MockItem>();
            using var scope = ServiceProvider.CreateScope();
            var db = scope.ServiceProvider.GetRequiredService<Data.AppDbContext>();

            if (selectedFormat == "bricklink")
            {
                var xmlString = await reader.ReadToEndAsync();
                XDocument doc;
                try
                {
                    doc = XDocument.Parse(xmlString);
                }
                catch
                {
                    uploadError = "Die XML-Datei ist ungültig.";
                    return;
                }
                if (!doc.Descendants("ITEM").Any())
                {
                    uploadError = "Die Bricklink-XML enthält keine Items.";
                    return;
                }
                foreach (var x in doc.Descendants("ITEM"))
                {
                    var partNum = x.Element("ITEMID")?.Value;
                    var colorId = int.TryParse(x.Element("COLOR")?.Value, out var cid) ? cid : (int?)null;
                    var qty = int.TryParse(x.Element("MINQTY")?.Value, out var q) ? q : 1;
                    int? mappedBrickId = null;
                    if (!string.IsNullOrEmpty(partNum))
                    {
                        var mapped = db.MappedBricks.FirstOrDefault(b => b.LegoPartNum == partNum);
                        if (mapped != null)
                            mappedBrickId = mapped.Id;
                    }
                    if (mappedBrickId == null)
                    {
                        unmappedItems.Add((partNum, colorId, qty));
                    }
                    items.Add(new MockItem
                    {
                        ExternalPartNum = partNum,
                        Quantity = qty,
                        BrickColorId = colorId,
                        MappedBrickId = mappedBrickId
                    });
                }
            }
            else if (selectedFormat == "rebrickable")
            {
                var csv = await reader.ReadToEndAsync();
                var lines = csv.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
                if (lines.Length < 2)
                {
                    uploadError = "Die CSV-Datei enthält keine Daten.";
                    return;
                }
                var header = lines[0].Split(',');
                var expectedHeader = new[] { "Part", "Color", "Quantity", "Is Spare" };
                if (header.Length != expectedHeader.Length || !expectedHeader.SequenceEqual(header))
                {
                    uploadError = $"Die CSV-Datei muss exakt die Spalten {string.Join(", ", expectedHeader)} enthalten.";
                    return;
                }
                int partIdx = Array.IndexOf(header, "Part");
                int colorIdx = Array.IndexOf(header, "Color");
                int qtyIdx = Array.IndexOf(header, "Quantity");
                for (int i = 1; i < lines.Length; i++)
                {
                    var cols = lines[i].Split(',');
                    if (cols.Length != expectedHeader.Length)
                    {
                        uploadError = $"Zeile {i + 1} hat nicht die korrekte Anzahl an Spalten.";
                        return;
                    }
                    var partNum = cols[partIdx];
                    var colorId = int.TryParse(cols[colorIdx], out var cid) ? cid : (int?)null;
                    var qty = int.TryParse(cols[qtyIdx], out var q) ? q : 1;
                    int? mappedBrickId = null;
                    if (!string.IsNullOrEmpty(partNum))
                    {
                        var mapped = db.MappedBricks.FirstOrDefault(b => b.LegoPartNum == partNum);
                        if (mapped != null)
                            mappedBrickId = mapped.Id;
                    }
                    if (mappedBrickId == null)
                    {
                        unmappedItems.Add((partNum, colorId, qty));
                    }
                    items.Add(new MockItem
                    {
                        ExternalPartNum = partNum,
                        Quantity = qty,
                        BrickColorId = colorId,
                        MappedBrickId = mappedBrickId
                    });
                }
            }

            var name = string.IsNullOrWhiteSpace(newMockName) ? file.Name : newMockName.Trim();
            var userUuid = await UserService.GetTokenAsync();
            if (string.IsNullOrEmpty(userUuid))
            {
                uploadError = "Nicht eingeloggt.";
                return;
            }
            // Nur Items mit gültigen MappedBrickId und BrickColorId, die auch wirklich existieren, speichern
            var validItems = new List<MockItem>();
            foreach (var i in items)
            {
                if (i.MappedBrickId == null || i.BrickColorId == null)
                    continue;
                var mappedExists = db.MappedBricks.Any(b => b.Id == i.MappedBrickId);
                var colorExists = db.BrickColors.Any(c => c.Id == i.BrickColorId);
                if (mappedExists && colorExists)
                    validItems.Add(i);
            }
            var mock = new Mock
            {
                Name = name,
                UserUuid = userUuid,
                MockType = selectedFormat,
                Items = validItems,
                Comment = string.IsNullOrWhiteSpace(newMockComment) ? null : newMockComment.Trim(),
                WebSource = string.IsNullOrWhiteSpace(newMockWebSource) ? null : newMockWebSource.Trim()
            };
            db.Mocks.Add(mock);
            db.SaveChanges();
            newMockName = string.Empty;
            newMockComment = string.Empty;
            newMockWebSource = string.Empty;
            await LoadMocks();
        }
        catch (Exception ex)
        {
            uploadError = $"Fehler beim Hochladen: {ex.Message}";
        }
    
    }
}
