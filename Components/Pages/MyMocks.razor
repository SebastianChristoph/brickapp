@page "/mymocs"

@using System.Xml.Linq
@using Microsoft.EntityFrameworkCore
@using Data.Entities
@using Microsoft.AspNetCore.Components.Forms
@using Services
@using MudBlazor
@using brickapp.Components.Shared.PartsListUpload
@using Helpers
@inject NavigationManager Nav
@inject IServiceProvider ServiceProvider
@inject Data.Services.ImageService ImageService
@inject UserService UserService
@inject Services.LoadingService LoadingService
@inject Services.NotificationService NotificationService

@using IBrowserFile = Microsoft.AspNetCore.Components.Forms.IBrowserFile

<MudText Typo="Typo.h4" GutterBottom="true">My MOCs</MudText>

@if (!string.IsNullOrWhiteSpace(_error))
{
    <MudAlert Severity="Severity.Error" Variant="Variant.Filled" Class="mb-4">
        @_error
        @if (!string.IsNullOrWhiteSpace(_errorDetails))
        {
            <MudDivider Class="my-2" />
            <MudText Typo="Typo.caption" Style="white-space:pre-wrap;">@_errorDetails</MudText>
        }
    </MudAlert>
}

<MudPaper Class="pa-4 mb-4">
    <MudText Typo="Typo.h6">Upload a new MOC</MudText>

    <MudTextField @bind-Value="newMockName"
                  Label="MOC name"
                  Disabled="_loading"
                  Style="width:260px;margin-top:8px;" />

    <MudTextField @bind-Value="newMockComment"
                  Label="Comment"
                  Disabled="_loading"
                  Lines="3"
                  TextFieldStyle="MudBlazor.TextFieldStyle.Multiline" />

    <MudTextField @bind-Value="newMockWebSource"
                  Label="Web Source"
                  Disabled="_loading" />

    <div style="margin-top:8px;">
        <label>Upload MOC image (max 3MB)</label>
        <InputFile OnChange="OnImageSelected" accept="image/*" disabled="@_loading" />
    </div>

    @if (!string.IsNullOrEmpty(imagePreviewUrl))
    {
        <div style="margin-top:8px;">
            <img src="@imagePreviewUrl" alt="Mock Bild Vorschau"
                 style="max-width:200px;max-height:200px;border:1px solid #ccc;padding:2px;" />
        </div>
    }

    <MudDivider Class="my-3" />

    <!-- Parts list upload via shared component -->
    <PartsListUploader TItem="MockItem"
                       Title="Upload Item List File"
                       HelpText="Supported: Rebrickable CSV (Part,Color,Quantity), Rebrickable XML, BrickLink XML. We validate structure; rows with unmapped parts or invalid colors are ignored."
                       Disabled="_loading"
                       Formats="@_mocFormats"
                       FormatLabelFunc="MocFormatLabel"
                       ParseAsync="ParseMocUploadAsync"
                       ShowAddButton="false"
                       ClearButtonText="Clear upload"
                       OnParsed="OnMocParsed" />

    @if (!string.IsNullOrWhiteSpace(uploadError))
    {
        <MudText Color="Color.Error" Class="mt-2">@uploadError</MudText>
    }

    <MudButton StartIcon="@Icons.Material.Filled.Add"
               Variant="Variant.Filled"
               Color="Color.Primary"
               OnClick="CreateMockFromUpload"
               Disabled="@(!fileReadyForUpload || _loading)"
               Class="ml-2 mt-3">
        Create new MOC
    </MudButton>
</MudPaper>

<MudPaper Class="pa-4">
    <MudText Typo="Typo.h6">Your MOCs</MudText>

    <MudStack Row="true" Justify="Justify.FlexEnd" Spacing="2" Style="margin-bottom: 16px;">
        <MudButton StartIcon="@Icons.Material.Filled.Delete"
                   Variant="Variant.Outlined"
                   Color="Color.Error"
                   OnClick="DeleteAllMocks"
                   Disabled="_loading"
                   Class="ml-2">
            Delete all MOCs
        </MudButton>
    </MudStack>

    <MudList T="string">
        @if (userMocks == null)
        {
            <MudText>Loading...</MudText>
        }
        else if (!userMocks.Any())
        {
            <MudAlert Severity="Severity.Info">No MOCs found.</MudAlert>
        }
        else
        {
            using var scope = ServiceProvider.CreateScope();
            var db = scope.ServiceProvider.GetRequiredService<Data.AppDbContext>();
            var userUuid = UserService.GetTokenAsync().Result;
            var inventory = db.InventoryItems.Where(i => i.AppUser.Uuid == userUuid).ToList();

            @foreach (var mock in userMocks)
            {
                var totalParts = mock.Items?.Sum(i => i.Quantity) ?? 0;
                int ownedParts = 0;

                if (mock.Items != null)
                {
                    foreach (var item in mock.Items)
                    {
                        if (item.MappedBrickId != null && item.BrickColorId != null)
                        {
                            var inv = inventory
                                .Where(invItem => invItem.MappedBrickId == item.MappedBrickId && invItem.BrickColorId == item.BrickColorId)
                                .Sum(invItem => invItem.Quantity);

                            ownedParts += Math.Min(inv, item.Quantity);
                        }
                    }
                }

                var percent = (totalParts > 0) ? (int)Math.Floor(100.0 * ownedParts / totalParts) : 0;

                <MudListItem T="string" Style="display:flex;align-items:center;justify-content:space-between;cursor:pointer">
                    <div style="display:flex;align-items:center;flex:1;gap:12px;">
                        <img src="@ImageService.GetMockImagePath(mock)" alt="Mock Bild"
                             style="width:56px;height:56px;object-fit:contain;border:1px solid #ccc;background:#fff;padding:2px;border-radius:6px;" />
                        <span style="flex:1" @onclick="@(() => Nav.NavigateTo($"/mockdetail/{mock.Id}"))">
                            <MudText><b>@mock.Name</b> <span style="color:#888;font-size:0.95em">(@mock.MockType)</span></MudText>
                            <MudText Typo="Typo.caption">Items: @totalParts</MudText>
                            <MudText Typo="Typo.caption">Owned: @ownedParts / @totalParts (@percent%)</MudText>

                            <OwnershipProgress OwnedCount="@ownedParts" TotalCount="@totalParts" />

                            <MudProgressLinear Value="@percent" Color="@(percent == 100 ? Color.Success : Color.Primary)" Style="max-width:120px;height:8px;margin-top:2px;" />

                            @if (!string.IsNullOrWhiteSpace(mock.WebSource))
                            {
                                <MudText Typo="Typo.caption">
                                    <a href="@mock.WebSource" target="_blank" rel="noopener noreferrer" style="color:#1976d2;text-decoration:underline;">Web-Source</a>
                                </MudText>
                            }
                            @if (!string.IsNullOrWhiteSpace(mock.Comment))
                            {
                                <MudText Typo="Typo.caption" Style="color:#666;"><br />Comment: @mock.Comment</MudText>
                            }
                        </span>
                    </div>

                    <MudButton Variant="Variant.Outlined"
                               Color="Color.Error"
                               Size="Size.Small"
                               Style="margin-left:8px"
                               Disabled="_loading"
                               OnClick="@(() => DeleteMock(mock.Id))">
                        Delete
                    </MudButton>
                </MudListItem>
            }
        }
    </MudList>
</MudPaper>

@code {
    // Keep old constants for MockType storage (DB)
    private static class Formats
    {
        public const string RebrickableCsv = "rebrickable_csv";
        public const string RebrickableXml = "rebrickable_xml";
        public const string BricklinkXml = "bricklink_xml";
    }

    private readonly PartsUploadFormat[] _mocFormats = new[]
    {
        PartsUploadFormat.RebrickableCsv,
        PartsUploadFormat.RebrickableXml,
        PartsUploadFormat.BricklinkXml
    };

    private string MocFormatLabel(PartsUploadFormat f) => f switch
    {
        PartsUploadFormat.RebrickableCsv => "Rebrickable CSV (Part,Color,Quantity)",
        PartsUploadFormat.RebrickableXml => "Rebrickable XML",
        PartsUploadFormat.BricklinkXml => "BrickLink XML",
        _ => f.ToString()
    };

    private List<Mock>? userMocks;

    private string uploadError = string.Empty;

    private string newMockName = string.Empty;
    private string newMockComment = string.Empty;
    private string newMockWebSource = string.Empty;

    private List<MockItem> uploadedItems = new();
    private bool fileReadyForUpload = false;

    private IBrowserFile? uploadedImage = null;
    private string imagePreviewUrl = string.Empty;

    private bool _loading = false;

    // Diagnostics
    private List<(string? PartNum, int? ColorId, int Quantity)> unmappedItems = new();
    private HashSet<int> invalidColorIds = new();
    private HashSet<int> invalidMappedBrickIds = new();

    // Page error like SetDetails
    private string? _error;
    private string? _errorDetails;
    private void SetError(Exception ex, string context = "")
    {
        _error = string.IsNullOrWhiteSpace(context)
            ? $"An error happened: {ex.Message}"
            : $"An error happened ({context}): {ex.Message}";
        _errorDetails = ex.ToString();
    }

    private async Task OnImageSelected(InputFileChangeEventArgs e)
    {
        uploadError = string.Empty;
        imagePreviewUrl = string.Empty;
        uploadedImage = null;

        var file = e.File;
        if (file == null) return;

        if (file.Size > 3 * 1024 * 1024)
        {
            uploadError = "The image can be max 3MB.";
            return;
        }

        uploadedImage = file;

        try
        {
            using var stream = file.OpenReadStream(3 * 1024 * 1024);
            using var ms = new MemoryStream();
            await stream.CopyToAsync(ms);
            var bytes = ms.ToArray();
            var base64 = Convert.ToBase64String(bytes);

            var mime = string.IsNullOrWhiteSpace(file.ContentType) ? "image/*" : file.ContentType;
            imagePreviewUrl = $"data:{mime};base64,{base64}";
        }
        catch (Exception ex)
        {
            uploadError = $"Error reading image: {ex.Message}";
        }
    }

    private async Task DeleteMock(int mockId)
    {
        if (_loading) return;

        try
        {
            var userUuid = await UserService.GetTokenAsync();
            if (string.IsNullOrEmpty(userUuid))
                return;

            using var scope = ServiceProvider.CreateScope();
            var db = scope.ServiceProvider.GetRequiredService<Data.AppDbContext>();

            var mock = db.Mocks.FirstOrDefault(m => m.Id == mockId && m.UserUuid == userUuid);
            if (mock != null)
            {
                ImageService.DeleteMockImage(mock);
                db.Mocks.Remove(mock);
                db.SaveChanges();
            }

            await LoadMocks();
        }
        catch (Exception ex)
        {
            SetError(ex, "DeleteMock");
            NotificationService.Error(_error ?? "DeleteMock failed.");
        }
    }

    private async Task DeleteAllMocks()
    {
        if (_loading) return;

        try
        {
            var userUuid = await UserService.GetTokenAsync();
            if (string.IsNullOrEmpty(userUuid))
                return;

            using var scope = ServiceProvider.CreateScope();
            var db = scope.ServiceProvider.GetRequiredService<Data.AppDbContext>();

            var mocks = db.Mocks.Where(m => m.UserUuid == userUuid).ToList();
            if (mocks.Any())
            {
                foreach (var mock in mocks)
                    ImageService.DeleteMockImage(mock);

                db.Mocks.RemoveRange(mocks);
                db.SaveChanges();
            }

            await LoadMocks();
        }
        catch (Exception ex)
        {
            SetError(ex, "DeleteAllMocks");
            NotificationService.Error(_error ?? "DeleteAllMocks failed.");
        }
    }

    private bool _loaded = false;
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender || _loaded) return;

        _loaded = true;

        try
        {
            await LoadMocks();
        }
        catch (Exception ex)
        {
            SetError(ex, "LoadMocks");
        }
        finally
        {
            StateHasChanged();
        }
    }

    private async Task LoadMocks()
    {
        using var scope = ServiceProvider.CreateScope();
        var db = scope.ServiceProvider.GetRequiredService<Data.AppDbContext>();
        var userUuid = await UserService.GetTokenAsync();

        if (string.IsNullOrEmpty(userUuid))
        {
            userMocks = new();
            return;
        }

        userMocks = db.Mocks
            .Where(m => m.UserUuid == userUuid)
            .Include(m => m.Items)
            .ToList();
    }

    // =========================
    // Upload parsing via shared component
    // =========================

    private async Task OnMocParsed(ParseResult<MockItem> result)
    {
        // reset state
        uploadError = string.Empty;
        uploadedItems.Clear();
        unmappedItems.Clear();
        invalidColorIds.Clear();
        invalidMappedBrickIds.Clear();
        fileReadyForUpload = false;

        // keep diagnostics
        if (result.Unmapped?.Any() == true)
            unmappedItems = result.Unmapped.Select(u => (u.PartNum, u.ColorId, u.Quantity)).ToList();

        if (result.InvalidColorIds?.Any() == true)
            invalidColorIds = new HashSet<int>(result.InvalidColorIds);

        // mapped items are the ones we can store
        uploadedItems = result.MappedItems ?? new();

        fileReadyForUpload = uploadedItems.Count > 0;

        if (!string.IsNullOrWhiteSpace(result.FatalError))
            uploadError = result.FatalError!;
        else if (!fileReadyForUpload && (unmappedItems.Count > 0 || invalidColorIds.Count > 0 || (result.InvalidRows?.Count ?? 0) > 0))
            uploadError = "No usable items after validation (unmapped / invalid colors / invalid rows).";
        else if (!fileReadyForUpload)
            uploadError = "No valid items found in file.";

        await InvokeAsync(StateHasChanged);
    }

    private Task<ParseResult<MockItem>> ParseMocUploadAsync(string content, PartsUploadFormat format)
    {
        // Parse into (partNum, colorIdFromFile, qty) where colorIdFromFile means:
        // - Rebrickable: RebrickableColorId
        // - BrickLink: BrickLink ColorId
        var (rows, invalidRows, invalidColorIdsFromFile) = format switch
        {
            PartsUploadFormat.RebrickableCsv => ParseRebrickableCsv_Rows(content),
            PartsUploadFormat.RebrickableXml => ParseRebrickableXml_Rows(content),
            PartsUploadFormat.BricklinkXml => ParseBricklinkXml_Rows(content),
            _ => (new List<(string PartNum, int ColorIdFromFile, int Qty, string ColorMode)>(),
                  new List<(string? PartNum, int? ColorId, int Qty, string Reason)> { (null, null, 0, "Unknown upload format selected.") },
                  new HashSet<int>())
        };

        // Map rows to DB IDs (MappedBrickId + BrickColorId) and ignore invalid ones
        return MapRowsToMockItemsAsync(rows, invalidRows, invalidColorIdsFromFile);
    }

    private async Task<ParseResult<MockItem>> MapRowsToMockItemsAsync(
        List<(string PartNum, int ColorIdFromFile, int Qty, string ColorMode)> rows,
        List<(string? PartNum, int? ColorId, int Qty, string Reason)> invalidRows,
        HashSet<int> invalidColorIdsFromFile)
    {
        var result = new ParseResult<MockItem>
        {
            InvalidColorIds = new HashSet<int>(invalidColorIdsFromFile),
            InvalidRows = invalidRows.Select(x => new InvalidRow(x.PartNum, x.ColorId, x.Qty, x.Reason)).ToList()
        };

        using var scope = ServiceProvider.CreateScope();
        var db = scope.ServiceProvider.GetRequiredService<Data.AppDbContext>();

        // Build caches for mapping
        var brickMap = await db.MappedBricks.AsNoTracking()
            .Where(b => b.LegoPartNum != null)
            .ToDictionaryAsync(b => b.LegoPartNum!, b => b.Id, StringComparer.OrdinalIgnoreCase);

        var validColorIds = await db.BrickColors.AsNoTracking().Select(c => c.Id).ToHashSetAsync();

        // RebrickableColorId -> BrickColor.Id
        var rbToDbColor = await db.BrickColors.AsNoTracking()
            .ToDictionaryAsync(c => c.RebrickableColorId, c => c.Id);

        // Name -> BrickColor.Id (for BrickLink name mapping)
        var nameToDbColor = await db.BrickColors.AsNoTracking()
            .Where(c => c.Name != null)
            .GroupBy(c => c.Name!)
            .ToDictionaryAsync(g => g.Key, g => g.First().Id, StringComparer.OrdinalIgnoreCase);

        foreach (var (partNum, colorIdFromFile, qty, colorMode) in rows)
        {
            if (!brickMap.TryGetValue(partNum, out var mappedBrickId))
            {
                result.Unmapped.Add(new UnmappedRow(partNum, colorIdFromFile, qty));
                continue;
            }

            int? dbColorId = null;

            if (string.Equals(colorMode, "rebrickable", StringComparison.OrdinalIgnoreCase))
            {
                if (rbToDbColor.TryGetValue(colorIdFromFile, out var cid))
                    dbColorId = cid;
                else
                {
                    result.InvalidColorIds.Add(colorIdFromFile);
                    result.InvalidRows.Add(new InvalidRow(partNum, colorIdFromFile, qty, "Unknown Rebrickable ColorId (not seeded)."));
                    continue;
                }
            }
            else // bricklink
            {
                if (BricklinkColorMap.IsNotApplicable(colorIdFromFile))
                {
                    result.InvalidColorIds.Add(colorIdFromFile);
                    result.InvalidRows.Add(new InvalidRow(partNum, colorIdFromFile, qty, "BrickLink ColorId 0 = Not Applicable."));
                    continue;
                }

                var blName = BricklinkColorMap.GetBrickColorName(colorIdFromFile);
                if (string.IsNullOrWhiteSpace(blName))
                {
                    result.InvalidColorIds.Add(colorIdFromFile);
                    result.InvalidRows.Add(new InvalidRow(partNum, colorIdFromFile, qty, "Unknown BrickLink ColorId."));
                    continue;
                }

                if (nameToDbColor.TryGetValue(blName, out var cid))
                    dbColorId = cid;
                else
                {
                    result.InvalidColorIds.Add(colorIdFromFile);
                    result.InvalidRows.Add(new InvalidRow(partNum, colorIdFromFile, qty, $"BrickLink color '{blName}' not found in BrickColors (name mismatch / missing)."));
                    continue;
                }
            }

            if (!dbColorId.HasValue || !validColorIds.Contains(dbColorId.Value))
            {
                // dbColorId itself invalid (shouldn’t happen if db is consistent)
                result.InvalidRows.Add(new InvalidRow(partNum, colorIdFromFile, qty, "Mapped BrickColorId not found in DB."));
                continue;
            }

            // add item (with correct DB ids)
            result.MappedItems.Add(new MockItem
            {
                ExternalPartNum = partNum,
                Quantity = qty <= 0 ? 1 : qty,
                MappedBrickId = mappedBrickId,
                BrickColorId = dbColorId.Value
            });
        }

        // Merge duplicates (same MappedBrickId + BrickColorId)
        result.MappedItems = result.MappedItems
            .GroupBy(i => new { i.MappedBrickId, i.BrickColorId })
            .Select(g =>
            {
                var first = g.First();
                first.Quantity = g.Sum(x => x.Quantity);
                return first;
            })
            .ToList();

        return result;
    }

    // =========================
    // Parsers -> normalized rows
    // =========================

    // Row shape: (PartNum, ColorIdFromFile, Qty, ColorMode["rebrickable"|"bricklink"])

    private (List<(string PartNum, int ColorIdFromFile, int Qty, string ColorMode)> rows,
             List<(string? PartNum, int? ColorId, int Qty, string Reason)> invalidRows,
             HashSet<int> invalidColorIds)
        ParseRebrickableCsv_Rows(string csv)
    {
        var rows = new List<(string PartNum, int ColorIdFromFile, int Qty, string ColorMode)>();
        var invalidRows = new List<(string? PartNum, int? ColorId, int Qty, string Reason)>();
        var invalidColorIds = new HashSet<int>();

        csv = (csv ?? "").Trim();
        var lines = csv.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
        if (lines.Length < 2)
        {
            invalidRows.Add((null, null, 0, "CSV has no data rows."));
            return (rows, invalidRows, invalidColorIds);
        }

        var header = lines[0].Split(',').Select(x => x.Trim()).ToArray();
        int partIdx = Array.FindIndex(header, h => h.Equals("Part", StringComparison.OrdinalIgnoreCase));
        int colorIdx = Array.FindIndex(header, h => h.Equals("Color", StringComparison.OrdinalIgnoreCase));
        int qtyIdx = Array.FindIndex(header, h => h.Equals("Quantity", StringComparison.OrdinalIgnoreCase));

        if (partIdx < 0 || colorIdx < 0 || qtyIdx < 0)
        {
            invalidRows.Add((null, null, 0, "Invalid Rebrickable CSV header. Expected: Part,Color,Quantity."));
            return (rows, invalidRows, invalidColorIds);
        }

        for (int i = 1; i < lines.Length; i++)
        {
            var cols = lines[i].Split(',');
            int maxIdx = Math.Max(partIdx, Math.Max(colorIdx, qtyIdx));
            if (cols.Length <= maxIdx) continue;

            var partNum = cols[partIdx]?.Trim();
            var rbColorId = int.TryParse(cols[colorIdx]?.Trim(), out var c) ? c : (int?)null;
            var qty = int.TryParse(cols[qtyIdx]?.Trim(), out var q) ? q : 0;

            if (string.IsNullOrWhiteSpace(partNum) || rbColorId is null || qty <= 0)
            {
                invalidRows.Add((partNum, rbColorId, qty, "Row missing Part/Color/Quantity (or qty<=0)."));
                continue;
            }

            rows.Add((partNum!, rbColorId.Value, qty, "rebrickable"));
        }

        return (rows, invalidRows, invalidColorIds);
    }

    private (List<(string PartNum, int ColorIdFromFile, int Qty, string ColorMode)> rows,
             List<(string? PartNum, int? ColorId, int Qty, string Reason)> invalidRows,
             HashSet<int> invalidColorIds)
        ParseBricklinkXml_Rows(string xml)
    {
        var rows = new List<(string PartNum, int ColorIdFromFile, int Qty, string ColorMode)>();
        var invalidRows = new List<(string? PartNum, int? ColorId, int Qty, string Reason)>();
        var invalidColorIds = new HashSet<int>();

        XDocument doc;
        try { doc = XDocument.Parse(xml); }
        catch
        {
            invalidRows.Add((null, null, 0, "Invalid XML."));
            return (rows, invalidRows, invalidColorIds);
        }

        var items = doc.Descendants().Where(x => x.Name.LocalName.Equals("ITEM", StringComparison.OrdinalIgnoreCase)).ToList();
        if (!items.Any())
        {
            invalidRows.Add((null, null, 0, "BrickLink XML: no <ITEM> nodes found."));
            return (rows, invalidRows, invalidColorIds);
        }

        foreach (var it in items)
        {
            var partNum = GetChild(it, "ITEMID")?.Trim();
            var colorStr = GetChild(it, "COLOR")?.Trim();

            var qtyStr = GetChild(it, "MINQTY") ?? GetChild(it, "QTY") ?? GetChild(it, "QUANTITY");
            var qty = int.TryParse(qtyStr, out var q) ? q : 0;

            var blColorId = int.TryParse(colorStr, out var c) ? c : (int?)null;

            if (string.IsNullOrWhiteSpace(partNum) || blColorId is null || qty <= 0)
            {
                invalidRows.Add((partNum, blColorId, qty, "Row missing ITEMID/COLOR/MINQTY (or qty<=0)."));
                continue;
            }

            rows.Add((partNum!, blColorId.Value, qty, "bricklink"));
        }

        return (rows, invalidRows, invalidColorIds);

        static string? GetChild(XElement parent, string name)
            => parent.Elements().FirstOrDefault(e => e.Name.LocalName.Equals(name, StringComparison.OrdinalIgnoreCase))?.Value;
    }

    private (List<(string PartNum, int ColorIdFromFile, int Qty, string ColorMode)> rows,
             List<(string? PartNum, int? ColorId, int Qty, string Reason)> invalidRows,
             HashSet<int> invalidColorIds)
        ParseRebrickableXml_Rows(string xml)
    {
        var rows = new List<(string PartNum, int ColorIdFromFile, int Qty, string ColorMode)>();
        var invalidRows = new List<(string? PartNum, int? ColorId, int Qty, string Reason)>();
        var invalidColorIds = new HashSet<int>();

        XDocument doc;
        try { doc = XDocument.Parse(xml); }
        catch
        {
            invalidRows.Add((null, null, 0, "Invalid XML."));
            return (rows, invalidRows, invalidColorIds);
        }

        // CASE A: Part/Color/Quantity
        var candidates = doc.Descendants()
            .Where(n =>
                n.Elements().Any(e => e.Name.LocalName.Equals("Part", StringComparison.OrdinalIgnoreCase) || e.Name.LocalName.Equals("PART", StringComparison.OrdinalIgnoreCase)) &&
                n.Elements().Any(e => e.Name.LocalName.Equals("Color", StringComparison.OrdinalIgnoreCase) || e.Name.LocalName.Equals("COLOR", StringComparison.OrdinalIgnoreCase)) &&
                n.Elements().Any(e => e.Name.LocalName.Equals("Quantity", StringComparison.OrdinalIgnoreCase) || e.Name.LocalName.Equals("QTY", StringComparison.OrdinalIgnoreCase)))
            .ToList();

        if (candidates.Any())
        {
            foreach (var n in candidates)
            {
                string? partNum =
                    n.Elements().FirstOrDefault(e => e.Name.LocalName.Equals("Part", StringComparison.OrdinalIgnoreCase) || e.Name.LocalName.Equals("PART", StringComparison.OrdinalIgnoreCase))?.Value?.Trim();

                string? colorStr =
                    n.Elements().FirstOrDefault(e => e.Name.LocalName.Equals("Color", StringComparison.OrdinalIgnoreCase) || e.Name.LocalName.Equals("COLOR", StringComparison.OrdinalIgnoreCase))?.Value?.Trim();

                string? qtyStr =
                    n.Elements().FirstOrDefault(e => e.Name.LocalName.Equals("Quantity", StringComparison.OrdinalIgnoreCase) || e.Name.LocalName.Equals("QTY", StringComparison.OrdinalIgnoreCase))?.Value?.Trim();

                var rbColorId = int.TryParse(colorStr, out var c) ? c : (int?)null;
                var qty = int.TryParse(qtyStr, out var q) ? q : 0;

                if (string.IsNullOrWhiteSpace(partNum) || rbColorId is null || qty <= 0)
                {
                    invalidRows.Add((partNum, rbColorId, qty, "Row missing Part/Color/Quantity (or qty<=0)."));
                    continue;
                }

                rows.Add((partNum!, rbColorId.Value, qty, "rebrickable"));
            }

            return (rows, invalidRows, invalidColorIds);
        }

        // CASE B: <ITEM> blocks (many Rebrickable exports look like BrickLink inventory XML; COLOR is BrickLink id)
        var items = doc.Descendants().Where(x => x.Name.LocalName.Equals("ITEM", StringComparison.OrdinalIgnoreCase)).ToList();
        if (!items.Any())
        {
            invalidRows.Add((null, null, 0, "Rebrickable XML: neither Part/Color/Quantity nor <ITEM> nodes found."));
            return (rows, invalidRows, invalidColorIds);
        }

        foreach (var it in items)
        {
            var partNum = GetChild(it, "ITEMID")?.Trim();
            var colorStr = GetChild(it, "COLOR")?.Trim();

            var qtyStr = GetChild(it, "MINQTY") ?? GetChild(it, "QTY") ?? GetChild(it, "QUANTITY");
            var qty = int.TryParse(qtyStr, out var q) ? q : 0;

            var blColorId = int.TryParse(colorStr, out var c) ? c : (int?)null;

            if (string.IsNullOrWhiteSpace(partNum) || blColorId is null || qty <= 0)
            {
                invalidRows.Add((partNum, blColorId, qty, "INVENTORY row missing ITEMID/COLOR/MINQTY (or qty<=0)."));
                continue;
            }

            rows.Add((partNum!, blColorId.Value, qty, "bricklink"));
        }

        return (rows, invalidRows, invalidColorIds);

        static string? GetChild(XElement parent, string name)
            => parent.Elements().FirstOrDefault(e => e.Name.LocalName.Equals(name, StringComparison.OrdinalIgnoreCase))?.Value;
    }

    // =========================
    // Create mock (changed: no uploadedFile, no auto-detect, ignore invalid/unmapped rows)
    // =========================

    private async Task CreateMockFromUpload()
    {
        if (_loading) return;

        _error = null;
        _errorDetails = null;

        uploadError = string.Empty;

        if (string.IsNullOrWhiteSpace(newMockName))
        {
            uploadError = "Please provide a name for the MOC.";
            return;
        }

        if (uploadedItems == null || uploadedItems.Count == 0)
        {
            uploadError = "Please upload a valid item list file.";
            return;
        }

        _loading = true;
        await InvokeAsync(StateHasChanged);
        await Task.Delay(100);
        LoadingService.Show("Creating your MOC...");

        try
        {
            using var scope = ServiceProvider.CreateScope();
            var db = scope.ServiceProvider.GetRequiredService<Data.AppDbContext>();

            var userUuid = await UserService.GetTokenAsync();
            if (string.IsNullOrEmpty(userUuid))
            {
                uploadError = "Not logged in.";
                return;
            }

            // ===== validate FK ids (should already be valid, but keep safety) =====
            var validBrickIds = await db.MappedBricks.AsNoTracking().Select(b => b.Id).ToHashSetAsync();
            var validColorIds = await db.BrickColors.AsNoTracking().Select(c => c.Id).ToHashSetAsync();

            invalidMappedBrickIds.Clear();
            invalidColorIds.Clear();

            foreach (var it in uploadedItems)
            {
                if (it.MappedBrickId.HasValue && it.MappedBrickId.Value > 0 && !validBrickIds.Contains(it.MappedBrickId.Value))
                    invalidMappedBrickIds.Add(it.MappedBrickId.Value);

                if (it.BrickColorId.HasValue && it.BrickColorId.Value > 0 && !validColorIds.Contains(it.BrickColorId.Value))
                    invalidColorIds.Add(it.BrickColorId.Value);
            }

            // UX-friendly: do NOT hard abort on unmapped/invalid — those were already ignored.
            // But if somehow invalid FK IDs exist -> abort.
            if (invalidColorIds.Any() || invalidMappedBrickIds.Any())
            {
                var parts = new List<string>();
                if (invalidColorIds.Any())
                    parts.Add($"Invalid BrickColorId(s): {string.Join(", ", invalidColorIds.OrderBy(x => x))}");
                if (invalidMappedBrickIds.Any())
                    parts.Add($"Invalid MappedBrickId(s): {string.Join(", ", invalidMappedBrickIds.OrderBy(x => x))}");

                uploadError = "Cannot create MOC. Fix these issues first:\n" + string.Join("\n", parts);
                NotificationService.Error("Creating MOC failed (invalid IDs).");
                return;
            }

            // Only valid items are already in uploadedItems
            var validItems = uploadedItems
                .Where(i => i.MappedBrickId != null && i.BrickColorId != null && i.Quantity > 0)
                .ToList();

            if (!validItems.Any())
            {
                uploadError = "No usable items after validation.";
                return;
            }

            // Store the chosen format as string MockType
            var mockType = _lastParsedFormat switch
            {
                PartsUploadFormat.RebrickableCsv => Formats.RebrickableCsv,
                PartsUploadFormat.RebrickableXml => Formats.RebrickableXml,
                PartsUploadFormat.BricklinkXml => Formats.BricklinkXml,
                _ => Formats.RebrickableCsv
            };

            var mock = new Mock
            {
                Name = newMockName.Trim(),
                UserUuid = userUuid,
                MockType = mockType,
                Items = validItems,
                Comment = string.IsNullOrWhiteSpace(newMockComment) ? null : newMockComment.Trim(),
                WebSource = string.IsNullOrWhiteSpace(newMockWebSource) ? null : newMockWebSource.Trim(),
            };

            db.Mocks.Add(mock);
            db.SaveChanges();

            if (uploadedImage != null)
            {
                try
                {
                    await ImageService.SaveMockImageAsync(uploadedImage, userUuid, mock.Id);
                    db.SaveChanges();
                }
                catch (Exception exImg)
                {
                    NotificationService.Error($"Image could not be saved: {exImg.Message}");
                }
            }

            // Reset UI
            newMockName = string.Empty;
            newMockComment = string.Empty;
            newMockWebSource = string.Empty;

            uploadedItems.Clear();
            fileReadyForUpload = false;

            unmappedItems.Clear();
            invalidColorIds.Clear();
            invalidMappedBrickIds.Clear();

            uploadedImage = null;
            imagePreviewUrl = string.Empty;
            uploadError = string.Empty;

            await LoadMocks();

            NotificationService.Success("MOC successfully created.");
        }
        catch (Exception ex)
        {
            SetError(ex, "CreateMockFromUpload");
            uploadError = _error ?? $"Error while saving: {ex.Message}";
            NotificationService.Error("Creating MOC failed.");
        }
        finally
        {
            LoadingService.Hide();
            _loading = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private PartsUploadFormat _lastParsedFormat = PartsUploadFormat.RebrickableCsv;
}
