@namespace brickisbrickapp.Components.Dialogs
@using MudBlazor
@using brickisbrickapp.Services
@using brickisbrickapp.Data.Entities
@inject MappedBrickService BrickService
@inject InventoryService InventoryService
@inject brickisbrickapp.Services.RebrickablePartImageService PartImageService
@inject brickisbrickapp.Services.NotificationService NotificationService

<MudDialog>
    <DialogContent>
        <MudStack Spacing="3">
            <!-- Brick Image -->
            @{
                var overlay = SelectedColor != null ? brickisbrickapp.Helpers.BrickColorHelper.GetHexForColor(SelectedColor.Name) : null;
            }
            <div style="margin-bottom:8px; min-height:68px; text-align:center;">
                @if (!string.IsNullOrWhiteSpace(_imageUrl))
                {
                    if (overlay != null)
                    {
                        <div class="brick" style="--brick-overlay:@overlay">
                            <img src="@_imageUrl" alt="" style="max-width:64px;max-height:64px;border-radius:4px;border:1px solid #ccc;" />
                        </div>
                    }
                    else
                    {
                        <img src="@_imageUrl" alt="" style="max-width:64px;max-height:64px;border-radius:4px;border:1px solid #ccc;" />
                    }
                }
                else
                {
                    <img src="/part_images/placeholder.png" alt="" style="max-width:64px;max-height:64px;opacity:0.5;border-radius:4px;border:1px solid #ccc;" />
                }
            </div>
            <style>
            .brick {
                position: relative;
                display: inline-block;
                isolation: isolate;
            }
            .brick img {
                display: block;
            }
            .brick::after {
                content: "";
                position: absolute;
                inset: 0;
                background: var(--brick-overlay, transparent);
                mix-blend-mode: multiply;
                pointer-events: none;
                border-radius: 4px;
            }
            </style>
            <!-- Brand Selection -->
            <MudSelect Value="Brand" Label="Brand" Variant="Variant.Outlined" ValueChanged="@((string value) => OnBrandChanged(value))">
                <MudSelectItem Value="@("Lego")">Lego</MudSelectItem>
                <MudSelectItem Value="@("BlueBrixx")">BlueBrixx</MudSelectItem>
                <MudSelectItem Value="@("Cada")">Cada</MudSelectItem>
                <MudSelectItem Value="@("Pantasy")">Pantasy</MudSelectItem>
                <MudSelectItem Value="@("Mould King")">Mould King</MudSelectItem>
            </MudSelect>

            <!-- Lego Part Number Autocomplete -->
            <MudAutocomplete T="MappedBrick"
                 ValueChanged="@OnSelectedBrickChanged"
                 Value="@SelectedBrick"
                 SearchFunc="@SearchBricksByBrandWithImages"
                 Label="Part number / Name"
                 ToStringFunc="@(b => b == null ? "" : GetBrickDisplay(b))"
                 ResetValueOnEmptyText="true"
                 MinCharacters="3"
                 Variant="Variant.Outlined">
                <ItemTemplate Context="brick">
                    <div style="display:flex;align-items:center;gap:8px;">
                        <img src="@GetBrickImageUrl(brick)" alt="" style="width:32px;height:32px;border-radius:4px;border:1px solid #ccc;" />
                        <span>@GetBrickDisplay(brick)</span>
                    </div>
                </ItemTemplate>
            </MudAutocomplete>


            <!-- Quick Color Chips -->
            @if (SelectedBrick != null && Colors.Any())
            {
                <MudStack Row="true" Spacing="1" Style="margin-bottom:8px;">
                    @foreach (var colorName in brickisbrickapp.Helpers.BrickColorHelper.CommonColors)
                    {
                        var colorObj = Colors.FirstOrDefault(c => c.Name == colorName);
                        if (colorObj != null)
                        {
                            <MudChip T="object" Color="Color.Primary" Variant="@(SelectedColor?.Name == colorName ? Variant.Filled : Variant.Outlined)" Style="cursor:pointer;" OnClick="@(() => OnQuickColorChip(colorObj))">
                                <span style="@GetColorDotStyle(colorObj)"></span> @colorName
                            </MudChip>
                        }
                    }
                </MudStack>
                <MudSelect T="BrickColor" @bind-Value="SelectedColor" Label="Color" Variant="Variant.Outlined">
                    @foreach (var color in Colors)
                    {
                        <MudSelectItem T="BrickColor" Value="@color">
                            <div style="display:flex; align-items:center; gap:8px;">
                                <span style="@GetColorDotStyle(color)"></span>
                                <span>@color.Name</span>
                            </div>
                        </MudSelectItem>
                    }
        </MudSelect>
    }

    <!-- Quantity -->
            <MudNumericField @bind-Value="Quantity" 
                 Label="Quantity" 
                 Min="1" 
                 Variant="Variant.Outlined" />

            <!-- Error Message -->
            @if (!string.IsNullOrEmpty(ErrorMessage))
            {
                <MudAlert Severity="Severity.Error">@ErrorMessage</MudAlert>
            }
        </MudStack>
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="Cancel">Cancel</MudButton>
        <MudButton Color="Color.Primary" OnClick="Save" Disabled="@(SelectedBrick == null || SelectedColor == null)">
            Add
        </MudButton>
    </DialogActions>
</MudDialog>

@code {
    [CascadingParameter]
    private IMudDialogInstance? MudDialog { get; set; }

    private string Brand = "Lego";
    private string? _imageUrl;
    [Parameter]
    public MappedBrick? SelectedBrick { get; set; }
    private BrickColor? SelectedColor;
    private int Quantity = 1;
    private List<BrickColor> Colors = new();
    private string ErrorMessage = "";
    private Dictionary<string, string> _brickImageCache = new();

    private void OnQuickColorChip(BrickColor color)
    {
        SelectedColor = color;
    }

        private string GetColorHex(BrickColor? color)
    {
        var rgb = color?.Rgb;
        if (string.IsNullOrWhiteSpace(rgb))
            return "transparent";
        return rgb.StartsWith("#") ? rgb : $"#{rgb}";
    }

    private string GetColorDotStyle(BrickColor color)
    {
        var hex = GetColorHex(color);
        return $"background-color:{hex}; width:12px; height:12px; border-radius:50%; display:inline-block; border:1px solid #ccc;";
    }

    protected override async Task OnInitializedAsync()
    {
        Colors = await BrickService.GetAllColorsAsync();
        await UpdateImageUrl();
    }

    private async Task UpdateImageUrl()
    {
        _imageUrl = null;
        if (SelectedBrick != null && !string.IsNullOrWhiteSpace(SelectedBrick.LegoPartNum))
        {
            _imageUrl = await PartImageService.GetPartImageUrlAsync(SelectedBrick.LegoPartNum);
        }
        StateHasChanged();
    }

    private async Task OnSelectedBrickChanged(MappedBrick? brick)
    {
        SelectedBrick = brick;
        await UpdateImageUrl();
    }

    private async Task OnBrandChanged(string brand)
    {
        Brand = brand ?? "Lego";
        await UpdateImageUrl();
    }


    private async Task<IEnumerable<MappedBrick>> SearchBricksByBrand(string searchText, CancellationToken cancellationToken)
    {
        if (string.IsNullOrWhiteSpace(searchText) || searchText.Length < 3)
            return new List<MappedBrick>();

        var all = await BrickService.GetAllMappedBricksAsync();
        return Brand switch
        {
            "Lego" => all.Where(b => (b.LegoPartNum?.Contains(searchText, StringComparison.OrdinalIgnoreCase) ?? false)
                                || (b.LegoName?.Contains(searchText, StringComparison.OrdinalIgnoreCase) ?? false)),
            "BlueBrixx" => all.Where(b => (b.BbPartNum?.Contains(searchText, StringComparison.OrdinalIgnoreCase) ?? false)
                                || (b.BbName?.Contains(searchText, StringComparison.OrdinalIgnoreCase) ?? false)),
            "Cada" => all.Where(b => (b.CadaPartNum?.Contains(searchText, StringComparison.OrdinalIgnoreCase) ?? false)
                                || (b.CadaName?.Contains(searchText, StringComparison.OrdinalIgnoreCase) ?? false)),
            "Pantasy" => all.Where(b => (b.PantasyPartNum?.Contains(searchText, StringComparison.OrdinalIgnoreCase) ?? false)
                                || (b.PantasyName?.Contains(searchText, StringComparison.OrdinalIgnoreCase) ?? false)),
            "Mould King" => all.Where(b => (b.MouldKingPartNum?.Contains(searchText, StringComparison.OrdinalIgnoreCase) ?? false)
                                || (b.MouldKingName?.Contains(searchText, StringComparison.OrdinalIgnoreCase) ?? false)),
            _ => Enumerable.Empty<MappedBrick>()
        };
    }

    private async Task<IEnumerable<MappedBrick>> SearchBricksByBrandWithImages(string searchText, CancellationToken cancellationToken)
    {
        var results = await SearchBricksByBrand(searchText, cancellationToken);
        foreach (var brick in results)
        {
            var partNum = brick.LegoPartNum;
            if (!string.IsNullOrWhiteSpace(partNum) && !_brickImageCache.ContainsKey(partNum))
            {
                var url = await PartImageService.GetPartImageUrlAsync(partNum);
                _brickImageCache[partNum] = string.IsNullOrWhiteSpace(url) ? "/part_images/placeholder.png" : url;
            }
        }
        return results;
    }

    private string GetBrickImageUrl(MappedBrick brick)
    {
        var partNum = brick.LegoPartNum;
        if (!string.IsNullOrWhiteSpace(partNum) && _brickImageCache.TryGetValue(partNum, out var url))
            return url;
        return "/part_images/placeholder.png";
    }

    private string GetBrickDisplay(MappedBrick b)
    {
        return Brand switch
        {
            "Lego" => $"{b.LegoPartNum} - {b.LegoName}",
            "BlueBrixx" => $"{b.BbPartNum} - {b.BbName}",
            "Cada" => $"{b.CadaPartNum} - {b.CadaName}",
            "Pantasy" => $"{b.PantasyPartNum} - {b.PantasyName}",
            "Mould King" => $"{b.MouldKingPartNum} - {b.MouldKingName}",
            _ => b.Name
        };
    }

    private void Cancel()
    {
        MudDialog?.Cancel();
    }

    private async Task Save()
    {
        ErrorMessage = "";

        if (SelectedBrick == null || SelectedColor == null || Quantity <= 0)
        {
            ErrorMessage = "Please fill out all fields.";
            return;
        }

        // Verifiziere, dass der Brick wirklich existiert
        var brick = await BrickService.GetLegoPartByNumberAsync(SelectedBrick.LegoPartNum!);
        if (brick == null)
        {
            ErrorMessage = "This Lego brick does not exist.";
            return;
        }

        // FÃ¼ge zum Inventory hinzu
        var success = await InventoryService.AddInventoryItemAsync(brick.Id, SelectedColor.Id, Brand, Quantity);
        if (success)
        {
            MudDialog?.Close(true);
        }
        else
        {
            ErrorMessage = "Error adding item.";
        }
    }
}
